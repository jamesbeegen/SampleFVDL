<?xml version="1.0" encoding="UTF-8"?>
<FVDL xmlns="xmlns://www.fortifysoftware.com/schema/fvdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.8" xsi:type="FVDL">
<Build>
  <SourceBasePath>/path/to/project/Samples/advanced/webgoat/WebGoat5.0</SourceBasePath>
</Build>
	<Vulnerabilities>
<Vulnerability>
  <ClassInfo>
    <ClassID>45BF957F-1A34-4E28-9B34-FEB83EC96792</ClassID>
    <Kingdom>Code Quality</Kingdom>
    <Type>Unreleased Resource</Type>
    <Subtype>Database</Subtype>
  </ClassInfo>
  <InstanceInfo>
    <InstanceID>1EEA24C519E307822F6D1FAD0AD7B45A</InstanceID>
    <InstanceSeverity>4.0</InstanceSeverity>
  </InstanceInfo>
  <AnalysisInfo>
    <Unified>
      <ReplacementDefinitions>
        <Def key="EnclosingFunction.name" value="_jspService()"/>
        <Def key="PrimaryLocation.file" value="main.jsp"/>
        <Def key="PrimaryLocation.line" value="163"/>
        <Def key="SinkFunction" value="print()"/>
        <Def key="SinkLocation.file" value="main.jsp"/>
        <Def key="SinkLocation.line" value="163"/>
        <Def key="SourceFunction" value="getParameter()"/>
        <Def key="SourceLocation.file" value="WebSession.java"/>
        <Def key="SourceLocation.line" value="472"/>
        <LocationDef path="WebContent/main.jsp" line="163" lineEnd="163" colStart="0" colEnd="0" key="SinkLocation"/>
        <LocationDef path="JavaSource/org/owasp/webgoat/session/WebSession.java" line="472" lineEnd="472" colStart="0" colEnd="0" key="SourceLocation"/>
      </ReplacementDefinitions>
      <Trace>
        <Primary>
          <Entry>
            <Node isDefault="true">
              <SourceLocation path="WebContent/main.jsp" line="163" lineEnd="163" colStart="0" colEnd="0" contextId="80" snippet="1DCC56558C0A13E42B2C59961371AE85#WebContent/main.jsp:163:163"/>
            </Node>
          </Entry>
        </Primary>
      </Trace>
    </Unified>
  </AnalysisInfo>
</Vulnerability>
<Vulnerability>
  <ClassInfo>
    <!-- Inactive rule -->
    <ClassID>FOO-BAR</ClassID>
  </ClassInfo>
  <InstanceInfo>
    <InstanceID>1EEA24C519E307822F6D1FAD0AD7B45A</InstanceID>
    <InstanceSeverity>4.0</InstanceSeverity>
  </InstanceInfo>
  <AnalysisInfo>
    <Unified>
      <Trace>
        <Primary>
          <Entry>
            <Node isDefault="true">
              <SourceLocation path="WebContent/main.jsp" line="163" lineEnd="163" colStart="0" colEnd="0" contextId="80" snippet="1DCC56558C0A13E42B2C59961371AE85#WebContent/main.jsp:163:163"/>
            </Node>
          </Entry>
        </Primary>
      </Trace>
    </Unified>
  </AnalysisInfo>
</Vulnerability>
<Vulnerability>
  <ClassInfo>
    <ClassID>45BF957F-1A34-4E28-9B34-FEB83EC96792</ClassID>
  </ClassInfo>
  <InstanceInfo>
    <InstanceID>1EEA24C519E307822F6D1FAD0AD7B45A</InstanceID>
    <InstanceSeverity>4.0</InstanceSeverity>
  </InstanceInfo>
  <AnalysisInfo>
    <Unified>
      <Trace>
        <Primary>
          <Entry>
            <Node isDefault="true">
              <!-- Unknow resource -->
              <SourceLocation path="WebContent/foo.jsp" line="163" lineEnd="163" colStart="0" colEnd="0" contextId="80" snippet="1DCC56558C0A13E42B2C59961371AE85#WebContent/main.jsp:163:163"/>
            </Node>
          </Entry>
        </Primary>
      </Trace>
    </Unified>
  </AnalysisInfo>
</Vulnerability>
	</Vulnerabilities>
<Description classID="AC87E716-8766-4F78-8851-86354C03A13B" contentType="preformatted">
  <Abstract>&lt;Content&gt;A cookie is created without the &lt;code&gt;secure&lt;/code&gt; flag set to &lt;code&gt;true&lt;/code&gt;.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Modern web browsers support a &lt;code&gt;secure&lt;/code&gt; flag for each cookie.  If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.
  &lt;Paragraph&gt;
  In this case a cookie created in &lt;Replace key="FirstTraceLocation.file"/&gt; at line &lt;Replace key="FirstTraceLocation.line"/&gt;, but &lt;code&gt;setSecure()&lt;/code&gt; is not called or is called with the value &lt;code&gt;false&lt;/code&gt;.
  &lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt; In the example below, a cookie added to the response without setting the &lt;code&gt;secure&lt;/code&gt; flag.
&lt;pre&gt;
	Cookie cookie = new Cookie("emailCookie", email);
	response.addCookie(cookie);
&lt;/pre&gt;

If your application uses both HTTPS and HTTP but does not set the &lt;code&gt;secure&lt;/code&gt; flag, cookies set during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.
      &lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Set the &lt;code&gt;Secure&lt;/code&gt; flag on all new cookies in order to instruct browsers not to send these cookies in the clear. This can be done by calling &lt;code&gt;setSecure(true)&lt;/code&gt;.

&lt;b&gt;Example 2:&lt;/b&gt;
&lt;pre&gt;
	Cookie cookie = new Cookie("emailCookie", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
&lt;/pre&gt;
      &lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Class Cookie</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2ee/sdk_1.3/techdocs/api/javax/servlet/http/Cookie.html#setSecure(boolean)</Source>
    </Reference>
    <Reference>
      <Title>Automated HTTPS Cookie Hijacking</Title>
      <Author>Mike Perry</Author>
      <Source>http://fscked.org/blog/fully-automated-active-https-cookie-hijacking</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 614</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A10 Insecure Configuration Management</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A9 Insecure Communications</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 4.1, 6.5.10</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 4.1, 6.3.1.4, 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="138700B9-C625-4262-9826-C8F3450D6838" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Attackers can control the filesystem path argument to &lt;Replace key="PrimaryCall.name"/&gt; at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt;, which allows them to access or modify otherwise protected files.&lt;AltParagraph&gt;Allowing user input to control paths used in filesystem operations could enable an attacker to access or modify otherwise protected system resources.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Path manipulation errors occur when the following two conditions are met:

1. An attacker can specify a path used in an operation on the filesystem. 

2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.

For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker. 
&lt;Paragraph&gt;
In this case, the attacker can specify the value that enters the program at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;, and this value is used to access a filesystem resource at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
&lt;b&gt;Example 1:&lt;/b&gt; The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as "&lt;code&gt;../../tomcat/conf/server.xml&lt;/code&gt;", which causes the application to delete one of its own configuration files. 

&lt;pre&gt;
String rName = request.getParameter("reportName");
File rFile = new File("/usr/local/apfr/reports/" + rName);
...
rFile.delete();
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension &lt;code&gt;.txt&lt;/code&gt;. 

&lt;pre&gt;
fis = new FileInputStream(cfg.getProperty("sub")+".txt");
amt = fis.read(arr);
out.println(arr);
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The best way to prevent path manipulation is with a level of indirection: create a list of legitimate resource names that a user is allowed to specify, and only allow the user to select from the list. With this approach the input provided by the user is never used directly to specify the resource name. 

In some situations this approach is impractical because the set of legitimate resource names is too large or too hard to keep track of. Programmers often resort to blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a white list of characters that are allowed to appear in the resource name and accept input composed exclusively of characters in the approved set.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>If the program is performing input validation, satisfy yourself that the validation is correct, and use Fortify Rules Builder to create a cleanse rule for the validation routine.
</Tip>
    <Tip>It is notoriously difficult to correctly implement a blacklist. If the validation logic relies on blacklisting, be skeptical. Consider different types of input encoding and different sets of meta-characters that might have special meaning when interpreted by different operating systems, databases, or other resources. Determine whether or not the blacklist can be updated easily, correctly, and completely if these requirements ever change.
</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Exploiting Software</Title>
      <Author>G. Hoglund, G. McGraw</Author>
      <Publisher>Addison-Wesley</Publisher>
      <PublishedDate>2004</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 73</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A4 Insecure Direct Object Reference</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3600 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="4280F38B-9FDB-454E-B495-89CF45CD51B7" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can dereference a null pointer on line &lt;Replace key="LastTraceLocation.line"/&gt; because it does not check the return value of &lt;Replace key="PrimaryCall.name"/&gt;, which might return null.&lt;AltParagraph&gt;The program can dereference a null pointer because it does not check the return value of a function that might return null.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.

&lt;Paragraph&gt;
In this case, an earlier return value is used without being checked in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt;  The following code does not check to see if the string returned by &lt;code&gt;getParameter()&lt;/code&gt; is null before calling the member function &lt;code&gt;compareTo()&lt;/code&gt;, potentially causing a null dereference. 

&lt;pre&gt;
String itemName = request.getParameter(ITEM_NAME);
	if (itemName.compareTo(IMPORTANT_ITEM)) {
		...
	}
	...
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt;. The following code shows a system property that is set to null and later dereferenced by a programmer who mistakenly assumes it will always be defined. 

&lt;pre&gt;
System.clearProperty("os.name");
...
String os = System.getProperty("os.name");
if (os.equalsIgnoreCase("Windows 95") )
	System.out.println("Not supported");
&lt;/pre&gt;

The traditional defense of this coding error is: 

"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value." 

But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;If a function can return an error code or any other evidence of its success or failure, always check for the error condition, even if there is no obvious way for it to occur. In addition to preventing security errors, many initially mysterious bugs have eventually led back to a failed method call with an unchecked return value.

Create an easy to use and standard way for dealing with failure in your application. If error handling is straightforward, programmers will be less inclined to omit it. One approach to standardized error handling is to write wrappers around commonly-used functions that check and handle error conditions without additional programmer intervention. When wrappers are implemented and adopted, the use of non-wrapped equivalents can be prohibited and enforced by using custom rules. 

&lt;b&gt;Example 3:&lt;/b&gt; The following code implements a wrapper around &lt;code&gt;getParameter()&lt;/code&gt; that checks the return value of &lt;code&gt;getParameter()&lt;/code&gt; against null and uses a default value if the requested parameter is not defined.  

&lt;pre&gt;
String safeGetParameter (HttpRequest request, String name)
{
String value = request.getParameter(name);
if (value == null) {
return getDefaultValue(name)
}
return value;
}
&lt;/pre&gt;
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Watch out for programmers who want to explain away this type of issue by saying "that can never happen because ...".  Chances are good that they have developed their intuition about the way the system works by using their development workstation. If your software will eventually run under different operating systems, operating system versions, hardware configurations, or runtime environments, their intuition may not apply.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 253, 690</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP3120 CAT II, APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="A53E6ED8-2131-4F10-B320-4158B7238CFA" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Without proper access control, the method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can execute a SQL statement on line &lt;Replace key="PrimaryLocation.line"/&gt; that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.&lt;AltParagraph&gt;Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Database access control errors occur when:

1.	Data enters a program from an untrusted source.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;

2.	The data is used to specify the value of a primary key in a SQL query. 
&lt;Paragraph&gt;
In this case the data is used by &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
&lt;b&gt;Example 1:&lt;/b&gt; The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user.  

&lt;pre&gt;
...
id = Integer.decode(request.getParameter("invoiceID"));
String query = "SELECT * FROM invoices WHERE id = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, id);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;

The problem is that the developer has failed to consider all of the possible values of &lt;code&gt;id&lt;/code&gt;. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Rather than relying on the presentation layer to restrict values submitted by the user, access control should be handled by the application and database layers. Under no circumstances should a user be allowed to retrieve or modify a row in the database without the appropriate permissions. Every query that accesses the database should enforce this policy, which can often be accomplished by simply including the current authenticated username as part of the query. 

&lt;b&gt;Example 2:&lt;/b&gt; The following code implements the same functionality as Example 1 but imposes an additional constraint requiring that the current authenticated user have specific access to the invoice. 

&lt;pre&gt;
...
userName = ctx.getAuthenticatedUserName();
id = Integer.decode(request.getParameter("invoiceID"));
String query = 
        "SELECT * FROM invoices WHERE id = ? AND user = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, id);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>SQL Injection Attacks by Example</Title>
      <Author>S. J. Friedl</Author>
      <Source>http://www.unixwiz.net/techtips/sql-injection.html</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 566</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A2 Broken Access Control</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A4 Insecure Direct Object Reference</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="6F84D4B0-3B7E-4463-A165-76135931D192" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; is not reachable from any method outside the class.  It is dead code.&lt;AltParagraph&gt;This method is not reachable from any method outside the class.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;This method is never called or is only called from other dead code.

&lt;b&gt;Example 1:&lt;/b&gt; In the following class, the method &lt;code&gt;doWork()&lt;/code&gt; can never be called.

&lt;pre&gt;
public class Dead {
  private void doWork() {
    System.out.println("doing work");
  }
  public static void main(String[] args) {
    System.out.println("running Dead");
  }
}
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code.

&lt;pre&gt;
public class DoubleDead {
  private void doTweedledee() {
    doTweedledumb();
  }
  private void doTweedledumb() {
    doTweedledee();
  }
  public static void main(String[] args) {
    System.out.println("running DoubleDead");
  }
}
&lt;/pre&gt;

(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;A dead method may indicate a bug in dispatch code. 

&lt;b&gt;Example 3:&lt;/b&gt; If method is flagged as dead named &lt;code&gt;getWitch()&lt;/code&gt; in a class that also contains the following dispatch method, it may be because of a copy-and-paste error. The 'w' case should return &lt;code&gt;getWitch()&lt;/code&gt; not &lt;code&gt;getMummy()&lt;/code&gt;.

&lt;pre&gt;
public ScaryThing getScaryThing(char st) {
  switch(st) {
    case 'm':
      return getMummy();
    case 'w':
      return getMummy();
    default:
      return getBlob();
  }
}
&lt;/pre&gt;

In general, you should repair or remove dead code. It causes additional complexity and maintenance burden without contributing to the functionality of the program.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>This issue may be a false positive if the program uses reflection to access private methods. (This is a non-standard practice. Private methods that are only invoked via reflection should be well documented.)</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 561</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>APP3050 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="789BB115-AAF5-4C03-BBC2-C4CFCC74C13A" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The function &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; sometimes fails to release a system resource allocated by &lt;Replace key="FirstTransitionFunction"/&gt; on line &lt;Replace key="FirstTraceLocation.line"/&gt;.&lt;AltParagraph&gt;The program can potentially fail to release a system resource.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The program can potentially fail to release a system resource.
&lt;Paragraph&gt;
    In this case, there are program paths on which the resource allocated in &lt;Replace key="FirstTraceLocation.file"/&gt; at line &lt;Replace key="FirstTraceLocation.line"/&gt; is not released.
&lt;/Paragraph&gt;

Resource leaks have at least two common causes:

- Error conditions and other exceptional circumstances.

- Confusion over which part of the program is responsible for releasing the resource.

Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.

&lt;b&gt;Example 1:&lt;/b&gt; The following method never closes the file handle it opens. The &lt;code&gt;finalize()&lt;/code&gt; method for &lt;code&gt;FileInputStream&lt;/code&gt; eventually calls &lt;code&gt;close()&lt;/code&gt;, but there is no guarantee as to how long it will take before the &lt;code&gt;finalize()&lt;/code&gt; method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.

&lt;pre&gt;
private void processFile(String fName) throws FileNotFoundException, IOException
{
  FileInputStream fis = new FileInputStream(fName);
  int sz;
  byte[] byteArray = new byte[BLOCK_SIZE];
  while ((sz = fis.read(byteArray)) != -1) {
    processBytes(byteArray, sz);
  }
}
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.

&lt;pre&gt;
  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;1. Never rely on &lt;code&gt;finalize()&lt;/code&gt; to reclaim resources. In order for an object's &lt;code&gt;finalize()&lt;/code&gt; method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's &lt;code&gt;finalize()&lt;/code&gt; method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to "bursty" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.

Finally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the &lt;code&gt;finalize()&lt;/code&gt; method will hang. 

2. Release resources in a &lt;code&gt;finally&lt;/code&gt; block. The code for Example 2 should be rewritten as follows:

&lt;pre&gt;
  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}
&lt;/pre&gt;

This solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. 

Also, the &lt;code&gt;execCxnSql&lt;/code&gt; method does not initialize the &lt;code&gt;stmt&lt;/code&gt; object to null. Instead, it checks to ensure that &lt;code&gt;stmt&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; before calling &lt;code&gt;safeClose()&lt;/code&gt;. Without the &lt;code&gt;null&lt;/code&gt; check, the Java compiler reports that &lt;code&gt;stmt&lt;/code&gt; might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  &lt;code&gt;stmt&lt;/code&gt; is initialized to &lt;code&gt;null&lt;/code&gt; in a more complex method, cases in which &lt;code&gt;stmt&lt;/code&gt; is used without being initialized will not be detected by the compiler. 
&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 404</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="08626078-D4AD-4E21-980E-98BA7972E2F6" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Without proper access control, the method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can execute a SQL statement on line &lt;Replace key="PrimaryLocation.line"/&gt; that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.&lt;AltParagraph&gt;Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Database access control errors occur when:

1.	Data enters a program from an untrusted source.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;

2.	The data is used to specify the value of a primary key in a SQL query. 
&lt;Paragraph&gt;
In this case the data is used by &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
&lt;b&gt;Example 1:&lt;/b&gt; The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user.  

&lt;pre&gt;
...
id = Integer.decode(request.getParameter("invoiceID"));
String query = "SELECT * FROM invoices WHERE id = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, id);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;

The problem is that the developer has failed to consider all of the possible values of &lt;code&gt;id&lt;/code&gt;. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Rather than relying on the presentation layer to restrict values submitted by the user, access control should be handled by the application and database layers. Under no circumstances should a user be allowed to retrieve or modify a row in the database without the appropriate permissions. Every query that accesses the database should enforce this policy, which can often be accomplished by simply including the current authenticated username as part of the query. 

&lt;b&gt;Example 2:&lt;/b&gt; The following code implements the same functionality as Example 1 but imposes an additional constraint requiring that the current authenticated user have specific access to the invoice. 

&lt;pre&gt;
...
userName = ctx.getAuthenticatedUserName();
id = Integer.decode(request.getParameter("invoiceID"));
String query = 
        "SELECT * FROM invoices WHERE id = ? AND user = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, id);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>SQL Injection Attacks by Example</Title>
      <Author>S. J. Friedl</Author>
      <Source>http://www.unixwiz.net/techtips/sql-injection.html</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 566</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A2 Broken Access Control</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A4 Insecure Direct Object Reference</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The function &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; might reveal system data or debugging information by calling &lt;Replace key="PrimaryCall.name"/&gt; on line &lt;Replace key="PrimaryLocation.line"/&gt;.  The information revealed by &lt;Replace key="PrimaryCall.name"/&gt; could help an adversary form a plan of attack.&lt;AltParagraph&gt;Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.

&lt;Paragraph&gt;
In this case &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; is called in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code prints an exception to the standard error stream:

&lt;pre&gt;
try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}
&lt;/pre&gt;

Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Write error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).

Even brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an "Access Denied" message can reveal that a file or user exists on the system.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Do not rely on wrapper scripts, corporate IT policy, or quick-thinking system administrators to prevent system information leaks. Write software that is secure on its own.</Tip>
    <Tip>This category of vulnerability does not apply to all types of programs. For example, if your application executes on a client machine where system information is already available to an attacker, or if you print system information only to a trusted log file, you can use AuditGuide to filter out this category.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 497</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3620 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="925A2CD9-F518-4500-B94C-34126420D183" contentType="preformatted">
  <Abstract>&lt;Content&gt;The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.
      &lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Use strong encryption algorithms with large key sizes to protect sensitive data. Examples of strong alternatives to DES are Rijndael (Advanced Encryption Standard or AES) and Triple DES (3DES). Before selecting an algorithm, first determine if your organization has standardized on a specific algorithm and implementation.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Fortify SCA will report a higher severity warning when RC4 or DES algorithms are used.</Tip>
    <Tip>Fortify SCA will report a lower severity warning when RC2 algorithm is used.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Java Cryptography Architecture Standard Algorithm Name Documentation</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/javase/6/docs/technotes/guides/security/StandardNames.html</Source>
    </Reference>
    <Reference>
      <Title>DES</Title>
      <Author>distributed.net</Author>
      <Source>http://www.distributed.net/des/</Source>
    </Reference>
    <Reference>
      <Title>FAQ About the Electronic Frontier Foundation's "DES Cracker" Machine</Title>
      <Publisher>Electronic Frontier Foundation</Publisher>
      <Source>http://w2.eff.org/Privacy/Crypto/Crypto_misc/DESCracker/HTML/19980716_eff_des_faq.html</Source>
    </Reference>
    <Reference>
      <Title>SDL Development Practices</Title>
      <Publisher>Microsoft</Publisher>
      <Source>http://download.microsoft.com/download/8/4/7/8471a3cb-e4bf-442a-bba4-c0c907d598c5/Michael%20Howard%20SDL%20Development%20Practices.ppsx</Source>
    </Reference>
    <Reference>
      <Title>Microsoft Security Fundamentals</Title>
      <Publisher>Microsoft</Publisher>
      <Source>http://eusecwest.com/esw06/esw06-cushman.ppt</Source>
    </Reference>
    <Reference>
      <Title>Related-key cryptanalysis of 3-WAY, Biham-DES, CAST, DES-X, NewDES, RC2, and TEA</Title>
      <Author>John Kelsey, Bruce Schneier, and David Wagner</Author>
    </Reference>
    <Reference>
      <Title>CWE ID 327</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.3, 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3150.1 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="749BCC9F-FE61-4DC0-9EF2-5EF1872C7717" contentType="preformatted">
  <Abstract>&lt;Content&gt;A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks. If the application shows the attacker a stack trace, it relinquishes information that makes the attacker's job significantly easier. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.

The application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a good security practice, and a good configuration will also define a last-chance error handler that catches any exception that could possibly be thrown by the application.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;A web application must be configured with a default error page. Your &lt;code&gt;web.xml&lt;/code&gt; should include at least the following entries:

&lt;pre&gt;
&amp;lt;error-page&amp;gt;
   &amp;lt;exception-type&amp;gt;java.lang.Throwable&amp;lt;/exception-type&amp;gt;
&amp;lt;location&amp;gt;/error.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&amp;lt;error-page&amp;gt;
   &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
&amp;lt;location&amp;gt;/error.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&amp;lt;error-page&amp;gt;
   &amp;lt;error-code&amp;gt;500&amp;lt;/error-code&amp;gt;
&amp;lt;location&amp;gt;/error.jsp&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Exploiting Software</Title>
      <Author>G. Hoglund, G. McGraw</Author>
      <Publisher>Addison-Wesley</Publisher>
      <PublishedDate>2004</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 7</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A7 Improper Error Handling</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.7</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.2, 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3120 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="03840C20-F22B-B900-B76E-63258B717C77" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can crash the program by dereferencing a null pointer on line &lt;Replace key="PrimaryLocation.line"/&gt;.&lt;AltParagraph&gt;The program can potentially dereference a null pointer, thereby causing a null pointer exception.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Null pointer exceptions usually occur when one or more of the programmer's assumptions is violated. A check-after-dereference error occurs when a program dereferences an object that can be null before checking if the object is null.
&lt;Paragraph&gt;
In this case a variable can be null when it is dereferenced at line &lt;Replace key="PrimaryLocation.line"/&gt;, thereby causing a null pointer exception. 
&lt;/Paragraph&gt;
Most null pointer issues result in general software reliability problems, but if attackers can intentionally trigger a null pointer dereference, they can use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.

&lt;b&gt;Example:&lt;/b&gt; In the following code, the programmer assumes that the variable &lt;code&gt;foo&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; and confirms this assumption by dereferencing the object. However, the programmer later contradicts the assumption by checking &lt;code&gt;foo&lt;/code&gt; against &lt;code&gt;null&lt;/code&gt;. If &lt;code&gt;foo&lt;/code&gt; can be &lt;code&gt;null&lt;/code&gt; when it is checked in the &lt;code&gt;if&lt;/code&gt; statement then it can also be &lt;code&gt;null&lt;/code&gt; when it is dereferenced and might cause a null pointer exception. Either the dereference is unsafe or the subsequent check is unnecessary. 

&lt;pre&gt;
foo.setBar(val);
...
if (foo != null) {
	...
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Implement careful checks before dereferencing objects that might be null. When possible, abstract null checks into wrappers around code that manipulates resources to ensure that they are applied in all cases and to minimize the places where mistakes can occur.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 476</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="73B5DD01-BFBE-4CD5-8759-C432873136FB" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; calls &lt;Replace key="PrimaryCall.name"/&gt;.  Socket-based communication in web applications is prone to error.&lt;AltParagraph&gt;Socket-based communication in web applications is prone to error.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The J2EE standard permits the use of sockets only for the purpose of communication with legacy systems when no higher-level protocol is available. Authoring your own communication protocol requires wrestling with difficult security issues, including: 

- In-band versus out-of-band signaling

- Compatibility between protocol versions

- Channel security

- Error handling

- Network constraints (firewalls)

- Session management

Without significant scrutiny by a security expert, chances are good that a custom communication protocol will suffer from security problems.

Many of the same issues apply to a custom implementation of a standard protocol. While there are usually more resources available that address security concerns related to implementing a standard protocol, these resources are also available to attackers.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Replace a custom communication protocol with an industry standard protocol or framework. Consider whether you can use a protocol such as HTTP, FTP, SMTP, CORBA, RMI/IIOP, EJB, or SOAP.

Consider the security track record of the protocol implementation you choose.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>If you are auditing a non-J2EE Java application, the J2EE Bad Practices categories may not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Java 2 Platform Enterprise Edition Specification, v1.4</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2ee/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 246</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="45BF957F-1A34-4E28-9B34-FEB83EC96792" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; sends unvalidated data to a web browser on line &lt;Replace key="PrimaryLocation.line"/&gt;, which can result in the browser executing malicious code.&lt;AltParagraph&gt;Sending unvalidated data to a web browser can result in the browser executing malicious code.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Cross-site scripting (XSS) vulnerabilities occur when:

1. Data enters a web application through an untrusted source, most frequently a web request or database.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;
2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. 
&lt;Paragraph&gt;
In this case the data is sent at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.

&lt;b&gt;Example 1:&lt;/b&gt; The following JSP code segment reads an employee ID, &lt;code&gt;eid&lt;/code&gt;, from an HTTP request and displays it to the user. 

&lt;pre&gt;
&amp;lt;% String eid = request.getParameter("eid"); %&amp;gt; 
...
Employee ID: &amp;lt;%= eid %&amp;gt;
&lt;/pre&gt;

The code in this example operates correctly if &lt;code&gt;eid&lt;/code&gt; contains only standard alphanumeric text. If &lt;code&gt;eid&lt;/code&gt; has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.

&lt;b&gt;Example 2:&lt;/b&gt; The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.

&lt;pre&gt; 
&amp;lt;%... 
 Statement stmt = conn.createStatement();
 ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
 if (rs != null) {
  rs.next(); 
  String name = rs.getString("name");
%&amp;gt;

Employee Name: &amp;lt;%= name %&amp;gt;
&lt;/pre&gt;

As in Example 1, this code functions correctly when the values of &lt;code&gt;name&lt;/code&gt; are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of &lt;code&gt;name&lt;/code&gt; is read from a database, whose contents are apparently managed by the application. However, if the value of &lt;code&gt;name&lt;/code&gt; originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Stored XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.

- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Stored XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.

- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.

Since XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. 

The most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. 

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:

In the content of a block-level element (in the middle of a paragraph of text):

- "&amp;lt;" is special because it introduces a tag.

- "&amp;amp;" is special because it introduces a character entity.

- "&amp;gt;" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening "&amp;lt;", but omitted it in error.

The following principles apply to attribute values:

- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.

- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.

- In attribute values without any quotes, white-space characters, such as space and tab, are special.

- "&amp;amp;" is special when used with certain attributes, because it introduces a character entity. 

In URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:

- Space, tab, and new line are special because they mark the end of the URL.

- "&amp;amp;" is special because it either introduces a character entity or separates CGI parameters.

- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.

- The "%" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, "%" must be filtered if input such as "%68%65%6C%6C%6F" becomes "hello" when it appears on the web page in question.


Within the body of a &amp;lt;SCRIPT&amp;gt; &amp;lt;/SCRIPT&amp;gt;:

- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. 

Server-side scripts:

- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (") on output might require additional filtering. 

Other possibilities:

- If an attacker submits a request in UTF-7, the special character '&amp;lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).

Once you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.

If input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].

Many application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>In Fortify Source Code Analysis Suite, the database is treated as a source of untrusted data for XSS vulnerabilities. If the database is a trusted resource in your environment, customize Audit Workbench to filter out data flow issues generated by database sources.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Understanding Malicious Content Mitigation for Web Developers</Title>
      <Publisher>CERT</Publisher>
      <Source>http://www.cert.org/tech_tips/malicious_code_mitigation.html#9</Source>
    </Reference>
    <Reference>
      <Title>HTML 4.01 Specification</Title>
      <Publisher>W3</Publisher>
      <Source>http://www.w3.org/TR/html4/sgml/entities.html#h-24.2</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 79, 80</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A4 Cross Site Scripting</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A1 Cross Site Scripting (XSS)</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3580 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; throws a generic exception making it harder for callers to do a good job of error handling and recovery.&lt;AltParagraph&gt;The method throws a generic exception making it harder for callers to do a good job of error handling and recovery.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Declaring a method to throw &lt;code&gt;Exception&lt;/code&gt; or &lt;code&gt;Throwable&lt;/code&gt; makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.

&lt;b&gt;Example:&lt;/b&gt; The following method throws three types of exceptions.

&lt;pre&gt;
public void doExchange()
  throws IOException, InvocationTargetException,
         SQLException {
  ...
}

&lt;/pre&gt;

While it might seem tidier to write 

&lt;pre&gt;
public void doExchange()
  throws Exception {
  ...
}
&lt;/pre&gt;

doing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of &lt;code&gt;doExchange()&lt;/code&gt; introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Do not declare methods to throw &lt;code&gt;Exception&lt;/code&gt; or &lt;code&gt;Throwable&lt;/code&gt;. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend &lt;code&gt;RuntimeException&lt;/code&gt; or &lt;code&gt;Error&lt;/code&gt; instead of &lt;code&gt;Exception&lt;/code&gt;, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 397</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A7 Improper Error Handling</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.7</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.2, 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3120 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="8843F319-8A22-4101-A378-C2B2F2597988" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; ignores an exception on line &lt;Replace key="PrimaryLocation.line"/&gt;, which could cause the program to overlook unexpected states and conditions.&lt;AltParagraph&gt;Ignoring an exception can cause the program to overlook unexpected states and conditions.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

Two dubious assumptions that are easy to spot in code are "this method call can never fail" and "it doesn't matter if this call fails". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.

&lt;b&gt;Example 1:&lt;/b&gt; The following code excerpt ignores a rarely-thrown exception from &lt;code&gt;doExchange()&lt;/code&gt;.

&lt;pre&gt;
try {
  doExchange();
}
catch (RareException e) {
  // this can never happen
}
&lt;/pre&gt;

If a &lt;code&gt;RareException&lt;/code&gt; were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;At a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a &lt;code&gt;RuntimeException&lt;/code&gt; or an &lt;code&gt;Error&lt;/code&gt;, both of which are unchecked exceptions. As of JDK 1.4, &lt;code&gt;RuntimeException&lt;/code&gt; has a constructor that makes it easy to wrap another exception. 

&lt;b&gt;Example 2:&lt;/b&gt; The code in Example 1 could be rewritten in the following way:

&lt;pre&gt;
try {
  doExchange();
}
catch (RareException e) {
  throw RuntimeException("This can never happen", e);
}
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>There are rare types of exceptions that can be discarded in some contexts. For instance, &lt;code&gt;Thread.sleep()&lt;/code&gt; throws &lt;code&gt;InterruptedException&lt;/code&gt;, and in many situations the program should behave the same way whether or not it was awoken prematurely.

&lt;pre&gt;
  try {
    Thread.sleep(1000);
  }
  catch (InterruptedException e){
    // The thread has been woken up prematurely, but its
    // behavior should be the same either way.
  }
&lt;/pre&gt;</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 391</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A7 Improper Error Handling</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.7</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.2, 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3120 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;On line &lt;Replace key="PrimaryLocation.line"/&gt; of &lt;Replace key="PrimaryLocation.file"/&gt;, the method &lt;Replace key="EnclosingFunction.name"/&gt; invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.&lt;AltParagraph&gt;Constructing a dynamic SQL statement with user input could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. &lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;SQL injection errors occur when:

1. Data enters a program from an untrusted source.

&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;

2. The data is used to dynamically construct a SQL query. 

&lt;Paragraph&gt;
In this case the data is passed to &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt; The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. 

&lt;pre&gt;
...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE owner = '" 
				+ userName + "' AND itemname = '"  
				+ itemName + "'";
	ResultSet rs = stmt.execute(query);
	...
&lt;/pre&gt;

The query that this code intends to execute follows:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = &amp;lt;userName&amp;gt;
	AND itemname = &amp;lt;itemName&amp;gt;;
&lt;/pre&gt;

However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if &lt;code&gt;itemName&lt;/code&gt; does not contain a single-quote character. If an attacker with the user name &lt;code&gt;wiley&lt;/code&gt; enters the string "&lt;code&gt;name' OR 'a'='a&lt;/code&gt;" for &lt;code&gt;itemName&lt;/code&gt;, then the query becomes the following:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';
&lt;/pre&gt;

The addition of the &lt;code&gt;OR 'a'='a'&lt;/code&gt; condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:

&lt;pre&gt;
	SELECT * FROM items;
&lt;/pre&gt;

This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the &lt;code&gt;items&lt;/code&gt; table, regardless of their specified owner.

&lt;b&gt;Example 2:&lt;/b&gt; This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name &lt;code&gt;wiley&lt;/code&gt; enters the string "&lt;code&gt;name'; DELETE FROM items; --&lt;/code&gt;" for &lt;code&gt;itemName&lt;/code&gt;, then the query becomes the following two queries:

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'
&lt;/pre&gt;

Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. 

Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "&lt;code&gt;name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a&lt;/code&gt;", the following three valid statements will be created: 

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';
&lt;/pre&gt;

One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:

- Target fields that are not quoted

- Find ways to bypass the need for certain escaped meta-characters

- Use stored procedures to hide the injected meta-characters

Manually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. 

Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.

The previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:

&lt;pre&gt;
...
String userName = ctx.getAuthenticatedUserName();
String itemName = request.getParameter("itemName");
String query =
 	       "SELECT * FROM items WHERE itemname=? AND owner=?"; 
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, itemName);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;

More complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the &lt;code&gt;WHERE&lt;/code&gt; clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. 
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>A common mistake is to use parameterized SQL statements that are constructed by concatenating user-controlled strings. Of course, this defeats the purpose of using parameterized SQL statements. If you are not certain that the strings used to form parameterized statements are constants controlled by the application, do not assume that they are safe because they are not being executed directly as SQL strings. Thoroughly investigate all uses of user-controlled strings in SQL statements and verify that none can be used to modify the meaning of the query. </Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>SQL Injection Attacks by Example</Title>
      <Author>S. J. Friedl</Author>
      <Source>http://www.unixwiz.net/techtips/sql-injection.html</Source>
    </Reference>
    <Reference>
      <Title>Stop SQL Injection Attacks Before They Stop You</Title>
      <Author>P. Litwin</Author>
      <Publisher>MSDN Magazine</Publisher>
      <PublishedDate>2004</PublishedDate>
      <Source>http://msdn.microsoft.com/msdnmag/issues/04/09/SQLInjection/default.aspx</Source>
    </Reference>
    <Reference>
      <Title>SQL Injection and Oracle, Part One</Title>
      <Author>P. Finnigan</Author>
      <Publisher>Security Focus</Publisher>
      <PublishedDate>2002</PublishedDate>
      <Source>http://www.securityfocus.com/infocus/1644</Source>
    </Reference>
    <Reference>
      <Title>Writing Secure Code, Second Edition</Title>
      <Author>M. Howard, D. LeBlanc</Author>
      <Publisher>Microsoft Press</Publisher>
      <PublishedDate>2003</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 89</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Injection Flaws</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3540.1 CAT, APP3540.3 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="57E7AB18-082F-4C18-8DE1-4115DB3917A3" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The random number generator implemented by &lt;Replace key="PrimaryCall.name"/&gt; cannot withstand a cryptographic attack.&lt;AltParagraph&gt;Standard pseudo-random number generators cannot withstand cryptographic attacks.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness in security-sensitive context.
&lt;Paragraph&gt;
In this case the function that generates weak random numbers is &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;
Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated. 

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it and a truly random value. In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts.

&lt;b&gt;Example:&lt;/b&gt; The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase.

&lt;pre&gt;
String GenerateReceiptURL(String baseUrl) {
	Random ranGen = new Random();
	ranGen.setSeed((new Date()).getTime());
return(baseUrl + Gen.nextInt(400000000) + ".html");
}
&lt;/pre&gt;

This code uses the &lt;code&gt;Random.nextInt()&lt;/code&gt; function to generate "unique" identifiers for the receipt pages it generates. Because &lt;code&gt;Random.nextInt()&lt;/code&gt; is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers, such as a cryptographic PRNG.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;When unpredictability is critical, as is the case with most security-sensitive uses of randomness, use a cryptographic PRNG. Regardless of the PRNG you choose, always use a value with sufficient entropy to seed the algorithm. (Values such as the current time offer only negligible entropy and should not be used.)

The Java language provides a cryptographic PRNG in &lt;code&gt;java.security.SecureRandom&lt;/code&gt;. As is the case with other algorithm-based classes in &lt;code&gt;java.security&lt;/code&gt;, &lt;code&gt;SecureRandom&lt;/code&gt; provides an implementation-independent wrapper around a particular set of algorithms. When you request an instance of a &lt;code&gt;SecureRandom&lt;/code&gt; object using &lt;code&gt;SecureRandom.getInstance()&lt;/code&gt;, you can request a specific implementation of the algorithm. If the algorithm is available, then it is given as a &lt;code&gt;SecureRandom&lt;/code&gt; object. If it is unavailable or if you do not specify a particular implementation, then you are given a &lt;code&gt;SecureRandom&lt;/code&gt; implementation selected by the system. 

Sun provides a single &lt;code&gt;SecureRandom&lt;/code&gt; implementation with the Java distribution named &lt;code&gt;SHA1PRNG&lt;/code&gt;, which Sun describes as computing:

"The SHA-1 hash over a true-random seed value concatenated with a 64-bit counter which is incremented by 1 for each operation. From the 160-bit SHA-1 output, only 64 bits are used [1]." 

However, the specifics of the Sun implementation of the &lt;code&gt;SHA1PRNG&lt;/code&gt; algorithm are poorly documented, and it is unclear what sources of entropy the implementation uses and therefore what amount of true randomness exists in its output. Although there is speculation on the Web about the Sun implementation, there is no evidence to contradict the claim that the algorithm is cryptographically strong and can be used safely in security-sensitive contexts.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Java Cryptography Architecture</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2se/1.4.2/docs/guide/security/CryptoSpec.html#AppA </Source>
    </Reference>
    <Reference>
      <Title>Building Secure Software</Title>
      <Author>J. Viega, G. McGraw</Author>
      <Publisher>Addison-Wesley</Publisher>
      <PublishedDate>2002</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 330</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.3, 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3150.2 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="CF4A0383-901C-4DF6-8AE7-D2E9927D5083" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Attackers can control the resource identifier argument to &lt;Replace key="PrimaryCall.name"/&gt; at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt;, which could enable them to access or modify otherwise protected system resources.&lt;AltParagraph&gt;Allowing user input to control resource identifiers could enable an attacker to access or modify otherwise protected system resources.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;A resource injection issue occurs when the following two conditions are met:
    
1. An attacker can specify the identifier used to access a system resource. 

For example, an attacker might be able to specify a port number to be used to connect to a network resource. 

2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.

For example, the program may give the attacker the ability to transmit sensitive information to a third-party server. 

&lt;Paragraph&gt;
In this case, the attacker can specify the value that enters the program at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;, and this value is used to access a system resource at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

Note: Resource injection that involves resources stored on the filesystem goes by the name path manipulation and is reported in separate category. See the path manipulation description for further details of this vulnerability. 

&lt;b&gt;Example:&lt;/b&gt; The following code uses a port number read from an HTTP request to create a socket.  

&lt;pre&gt;
String remotePort = request.getParameter("remotePort");
...
ServerSocket srvr = new ServerSocket(remotePort);
Socket skt = srvr.accept(); 
...
&lt;/pre&gt;

The kind of resource affected by user input indicates the kind of content that may be dangerous.  For example, data containing special characters like period, slash, and backslash are risky when used in methods that interact with the file system. Similarly, data that contains URLs and URIs is risky for functions that create remote connections.
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The best way to prevent resource injection is with a level of indirection: create a list of legitimate resource names that a user is allowed to specify, and only allow the user to select from the list. With this approach the input provided by the user is never used directly to specify the resource name. 

In some situations this approach is impractical because the set of legitimate resource names is too large or too hard to keep track of. Programmers often resort to blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a white list of characters that are allowed to appear in the resource name and accept input composed exclusively of characters in the approved set.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>If the program is performing input validation, satisfy yourself that the validation is correct, and use Fortify Rules Builder to create a cleanse rule for the validation routine.
</Tip>
    <Tip>It is notoriously difficult to correctly implement a blacklist. If the validation logic relies on blacklisting, be skeptical. Consider different types of input encoding and different sets of meta-characters that might have special meaning when interpreted by different operating systems, databases, or other resources. Determine whether or not the blacklist can be updated easily, correctly, and completely if these requirements ever change.
</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Exploiting Software</Title>
      <Author>G. Hoglund, G. McGraw</Author>
      <Publisher>Addison-Wesley</Publisher>
      <PublishedDate>2004</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 99</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A4 Insecure Direct Object Reference</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3600 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="8ECE1D9E-AE40-4AD1-9ECB-6D024DBF8FCA" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; calls &lt;Replace key="PrimaryCall.name"/&gt;  on line &lt;Replace key="PrimaryLocation.line"/&gt;.  Thread management in a web application is forbidden in some circumstances and is always highly error prone.&lt;AltParagraph&gt;Thread management in a web application is forbidden in some circumstances and is always highly error prone.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Thread management in a web application is forbidden by the J2EE standard in some circumstances and is always highly error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application container. Even without interfering with the container, thread management usually leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Avoid managing threads directly from within the web application. Instead use standards such as message driven beans and the EJB timer service that are provided by the application container.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>If you are auditing a non-J2EE Java application, the J2EE Bad Practices categories may not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Java 2 Platform Enterprise Edition Specification, v1.4</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2ee/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 383</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="8303786C-2D44-445D-857D-1C929841AECC" contentType="preformatted">
  <Abstract>&lt;Content&gt;The &lt;code&gt;equals()&lt;/code&gt; method is called on an object that does not implement &lt;code&gt;equals()&lt;/code&gt;.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;When comparing objects, developers developers usually want to compare properties of objects. However, calling &lt;code&gt;equals()&lt;/code&gt; on a class (or any super class/interface) that does not explicitly implement &lt;code&gt;equals()&lt;/code&gt; results in a call to the &lt;code&gt;equals()&lt;/code&gt; method inherited from &lt;code&gt;java.lang.Object&lt;/code&gt;. Instead of comparing object member fields or other properties, &lt;code&gt;Object.equals()&lt;/code&gt; compares two object instances to see if they are the same. Although there are legitimate uses of &lt;code&gt;Object.equals()&lt;/code&gt;, it is often an indication of buggy code.

&lt;b&gt;Example 1:&lt;/b&gt;
&lt;pre&gt;
public class AccountGroup
{
	private int gid;

	public int getGid()
	{
		return gid;
	}

	public void setGid(int newGid)
	{
		gid = newGid;
	}
}
...
public class CompareGroup
{
	public boolean compareGroups(AccountGroup group1, AccountGroup group2)
	{
		return group1.equals(group2);   //equals() is not implemented in AccountGroup
	}
}
&lt;/pre&gt;

        &lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Verify that the use of &lt;code&gt;Object.equals()&lt;/code&gt; is really the method you intend to call. If not, implement an &lt;code&gt;equals()&lt;/code&gt; method or use a different method for comparing objects.

&lt;b&gt;Example 2:&lt;/b&gt; The following code adds an &lt;code&gt;equals()&lt;/code&gt; method to the example from the Explanation section.
&lt;pre&gt;
public class AccountGroup
{
	private int gid;

	public int getGid()
	{
		return gid;
	}

	public void setGid(int newGid)
	{
		gid = newGid;
	}

	public boolean equals(AccountGroup group)
	{
	    return (gid == group.getGid()); 
	}
}
...
public class CompareGroup
{
	public static boolean compareGroups(AccountGroup group1, AccountGroup group2)
	{
		return group1.equals(group2);
	}
}
&lt;/pre&gt;
        &lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Fortify SCA detects when an object's static type does not implement equals(). This issue might be a false positive if an object's dynamic type implements equals().</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 398</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="8818735A-08BB-4274-AE6F-3DE087AAE3C0" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; calls &lt;Replace key="PrimaryCall.name"/&gt;  on line &lt;Replace key="PrimaryLocation.line"/&gt;.  Thread management in a web application is forbidden in some circumstances and is always highly error prone.&lt;AltParagraph&gt;Thread management in a web application is forbidden in some circumstances and is always highly error prone.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Thread management in a web application is forbidden by the J2EE standard in some circumstances and is always highly error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application container. Even without interfering with the container, thread management usually leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Avoid managing threads directly from within the web application. Instead use standards such as message driven beans and the EJB timer service that are provided by the application container.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>If you are auditing a non-J2EE Java application, the J2EE Bad Practices categories may not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Java 2 Platform Enterprise Edition Specification, v1.4</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2ee/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 383</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Any information revealed in the HTML comment at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt; could help an adversary learn about the system and form a plan of attack.&lt;AltParagraph&gt;Any information revealed in an HTML comment might help an adversary learn about the system and form a plan of attack.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;HTML comments provide an attacker with an easy source of information about a dynamically generated web page.

&lt;b&gt;Example 1:&lt;/b&gt;

&lt;pre&gt;
&amp;lt;!-- TBD: this needs a security audit --&amp;gt;
&amp;lt;form method="POST" action="recalcOrbit"&amp;gt;
...
&lt;/pre&gt;

Even comments that seem innocuous may be useful to someone trying to understand the way the system is built.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Replace HTML comments with JSP comments (which will not be transmitted to the user).

&lt;b&gt;Example 1 Revisited:&lt;/b&gt; The following code has been rewritten to use JSP comments, which will not be displayed to the user.

&lt;pre&gt;
&amp;lt;%-- TBD: this needs a security audit --%&amp;gt;
&amp;lt;form method="POST" action="recalcOrbit"&amp;gt;
...
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 615</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3620 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="A1172BFC-2902-4E59-A9C7-C80B132F30CD0" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The file &lt;Replace key="PrimaryLocation.file"/&gt; interprets unvalidated user input as source code on line &lt;Replace key="PrimaryLocation.line"/&gt;. Interpreting user-controlled instructions at run-time can allow attackers to execute malicious code.&lt;AltParagraph&gt;Interpreting user-controlled instructions at run-time can allow attackers to execute malicious code.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Many modern programming languages allow dynamic interpretation of source instructions. This capability allows programmers to perform dynamic instructions based on input received from the user. Code injection vulnerabilities occur when the programmer incorrectly assumes that instructions supplied directly from the user will perform only innocent operations, such as performing simple calculations on active user objects or otherwise modifying the user's state. However, without proper validation, a user might specify operations the programmer does not intend.
 
&lt;b&gt;Example:&lt;/b&gt; In this classic code injection example, the application implements a basic calculator that allows the user to specify commands for execution. 

&lt;pre&gt;
...
	userOp = form.operation.value;
	calcResult = eval(userOp);
...
&lt;/pre&gt;

The program behaves correctly when the &lt;code&gt;operation&lt;/code&gt; parameter is a benign value, such as &amp;quot;8 + 7 * 2&amp;quot;, in which case the &lt;code&gt;calcResult&lt;/code&gt; variable is assigned a value of 22. However, if an attacker specifies languages operations that are both valid and malicious, those operations would be executed with the full privilege of the parent process.  Such attacks are even more dangerous when the underlying language provides access to system resources or allows execution of system commands. In the case of JavaScript, the attacker can utilize this vulnerability to perform a cross-site scripting attack. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;
			Avoid dynamic code interpretation whenever possible. If your program's functionality requires code to be interpreted dynamically, the likelihood of attack can be minimized by constraining the code your program will execute dynamically as much as possible, limiting it to an application- and context-specific subset of the base programming language. 
 
If dynamic code execution is required, unvalidated user input should never be directly executed and interpreted by the application.  Instead, a level of indirection should be introduced: create a list of legitimate operations and data objects that users are allowed to specify, and only allow users to select from the list. With this approach, input provided by users is never executed directly.
		
		&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 95</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Injection Flaws</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3570 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="3B074389-826B-4DDA-9FEF-05ECD125D1FC" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; should compare strings with the &lt;code&gt;equals()&lt;/code&gt; method, not &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;.&lt;AltParagraph&gt;Strings should be compared with the &lt;code&gt;equals()&lt;/code&gt; method, not &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;This program uses &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt; to compare two strings for equality, which compares two objects for equality, not their values. Chances are good that the two references will never be equal.

&lt;b&gt;Example 1:&lt;/b&gt; The following branch will never be taken.

&lt;pre&gt;
  if (args[0] == STRING_CONSTANT) {
      logger.info("miracle");
  }
&lt;/pre&gt;

The &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators will only behave as expected when they are used to compare strings contained in objects that are equal. The most common way for this to occur is for the strings to be interned, whereby the strings are added to a pool of objects maintained by the &lt;code&gt;String&lt;/code&gt; class. Once a string is interned, all uses of that string will use the same object and equality operators will behave as expected. All string literals and string-valued constants are interned automatically. Other strings can be interned manually be calling &lt;code&gt;String.intern()&lt;/code&gt;, which will return a canonical instance of the current string, creating one if necessary.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Use &lt;code&gt;equals()&lt;/code&gt; to compare strings. 

&lt;b&gt;Example 2:&lt;/b&gt; The code in Example 1 could be rewritten in the following way:

&lt;pre&gt;
  if (STRING_CONSTANT.equals(args[0])) {
      logger.info("could happen");
  }
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Developers will sometimes compare strings for reference equality in order to "avoid the inefficiency" of calling &lt;code&gt;equals()&lt;/code&gt; right off the bat:

&lt;pre&gt;
 if (args[0] == STRING_CONSTANT) {
    doWork(args[0]);
 } else if (STRING_CONSTANT.equals(args[0])) {
    doWork(args[0]);
 }
&lt;/pre&gt;

In many circumstances this small performance gain comes at the cost of duplicated or convoluted code. Because &lt;code&gt;String.equals()&lt;/code&gt; performs a &lt;code&gt;==&lt;/code&gt; comparison before doing any deeper evaluation, the performance benefits of using &lt;code&gt;==&lt;/code&gt; instead of &lt;code&gt;String.equals()&lt;/code&gt; are limited to the overhead of performing a method call and are likely to be negligible in most environments.
Do a performance comparison for your program.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 597</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="F972FE42-6C15-47D2-BD5C-448166A574C2" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Using &lt;Replace key="PrimaryCall.name"/&gt; rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.&lt;AltParagraph&gt;Using &lt;code&gt;System.out&lt;/code&gt; or &lt;code&gt;System.err&lt;/code&gt; rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;&lt;b&gt;Example 1:&lt;/b&gt; The first Java program that a developer learns to write often looks like this:

&lt;pre&gt;
public class MyClass 
  public static void main(String[] args) {
    System.out.println("hello world");
  }
}
&lt;/pre&gt;

While most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using &lt;code&gt;System.out.println()&lt;/code&gt;.

The problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.

Developers widely accept the need for structured logging, but many continue to use system output streams in their "pre-production" development. If the code you are reviewing is past the initial phases of development, use of &lt;code&gt;System.out&lt;/code&gt; or &lt;code&gt;System.err&lt;/code&gt; may indicate an oversight in the move to a structured logging system.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Use a Java logging facility rather than &lt;code&gt;System.out&lt;/code&gt; or &lt;code&gt;System.err&lt;/code&gt;. 

&lt;b&gt;Example 2:&lt;/b&gt; For example, the "hello world" program above can be re-written using log4j like this:

&lt;pre&gt;
import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =     
            Logger.getLogger(MyClass.class);

  public static void main(String[] args) {
    BasicConfigurator.configure();
    logger.info("hello world");
  }
}
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 398</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A7 Improper Error Handling</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.7</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.2, 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3620 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="C204F020-1CA1-4c25-A6CB-BAA69CA2DA0B" contentType="preformatted">
  <Abstract>&lt;Content&gt;Hardcoded passwords can compromise system security in a way that cannot be easily remedied.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.
&lt;Paragraph&gt;
In this case a hardcoded password was found in the call to &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code uses a hardcoded password to connect to a database:

&lt;pre&gt;
...
DriverManager.getConnection(url, "scott", "tiger");
...
&lt;/pre&gt;

This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the &lt;code&gt;javap -c&lt;/code&gt; command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:

&lt;pre&gt;
javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.

Some third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Avoid hardcoding passwords in source code and avoid using default passwords. If a hardcoded password is the default, require that it be changed and remove it from the source code.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword and FortifyNotPassword can be used to indicate which fields and variables represent passwords.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 259</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.3.1.3, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3340 CAT I, APP3350 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="5760613C-9AF8-41EF-8431-66B6FBD4717A" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; calls &lt;Replace key="PrimaryCall.name"/&gt; with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.&lt;AltParagraph&gt;Executing commands from an untrusted source or in an untrusted environment can cause an application to execute malicious commands on behalf of an attacker.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Command injection vulnerabilities take two forms:

- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.

- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.

In this case we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the command that is executed. Command injection vulnerabilities of this type occur when:

1. Data enters the application from an untrusted source.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;.
&lt;/Paragraph&gt;
2. The data is used as or as part of a string representing a command that is executed by the application. 
&lt;Paragraph&gt;
In this case the command is executed by &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. 

&lt;b&gt;Example 1:&lt;/b&gt; The following code from a system utility uses the system property &lt;code&gt;APPHOME&lt;/code&gt; to determine the directory in which it is installed and then executes an initialization script based on a relative path from the specified directory. 

&lt;pre&gt;
	...
	String home = System.getProperty("APPHOME");
	String cmd = home + INITCMD; 
	java.lang.Runtime.getRuntime().exec(cmd);
	...
&lt;/pre&gt;

The code in Example 1 allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the system property &lt;code&gt;APPHOME&lt;/code&gt; to point to a different path containing a malicious version of &lt;code&gt;INITCMD&lt;/code&gt;. Because the program does not validate the value read from the environment, if an attacker can control the value of the system property &lt;code&gt;APPHOME&lt;/code&gt;, then they can fool the application into running malicious code and take control of the system.

&lt;b&gt;Example 2:&lt;/b&gt; The following code is from an administrative web application designed allow users to kick off a backup of an Oracle database using a batch-file wrapper around the &lt;code&gt;rman&lt;/code&gt; utility and then run a &lt;code&gt;cleanup.bat&lt;/code&gt; script to delete some temporary files. The script &lt;code&gt;rmanDB.bat&lt;/code&gt; accepts a single command line parameter, which specifies what type of backup to perform. Because access to the database is restricted, the application runs the backup as a privileged user. 

&lt;pre&gt;
...
String btype = request.getParameter("backuptype");
String cmd = new String("cmd.exe /K 
\"c:\\util\\rmanDB.bat "+btype+"&amp;amp;&amp;amp;c:\\utl\\cleanup.bat\"")
System.Runtime.getRuntime().exec(cmd);
...
&lt;/pre&gt;

The problem here is that the program does not do any validation on the &lt;code&gt;backuptype&lt;/code&gt; parameter read from the user. Typically the &lt;code&gt;Runtime.exec()&lt;/code&gt; function will not execute multiple commands, but in this case the program first runs the &lt;code&gt;cmd.exe&lt;/code&gt; shell in order to run multiple commands with a single call to &lt;code&gt;Runtime.exec()&lt;/code&gt;. Once the shell is invoked, it will happily execute multiple commands separated by two ampersands. If an attacker passes a string of the form &lt;code&gt;"&amp;amp;&amp;amp; del c:\\dbms\\*.*"&lt;/code&gt;, then the application will execute this command along with the others specified by the program. Because of the nature of the application, it runs with the privileges necessary to interact with the database, which means whatever command the attacker injects will run with those privileges as well. 

&lt;b&gt;Example 3:&lt;/b&gt; The following code is from a web application that allows users access to an interface through which they can update their password on the system. Part of the process for updating passwords in certain network environments is to run a &lt;code&gt;make&lt;/code&gt; command in the &lt;code&gt;/var/yp&lt;/code&gt; directory, the code for which is shown below. 

&lt;pre&gt;
...
System.Runtime.getRuntime().exec("make");
...
&lt;/pre&gt;

The problem here is that the program does not specify an absolute path for make and fails to clean its environment prior to executing the call to &lt;code&gt;Runtime.exec()&lt;/code&gt;. If an attacker can modify the &lt;code&gt;$PATH&lt;/code&gt; variable to point to a malicious binary called &lt;code&gt;make&lt;/code&gt; and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's &lt;code&gt;make&lt;/code&gt; will now be run with these privileges, possibly giving the attacker complete control of the system.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Do not allow users to have direct control over the commands executed by the program. In cases where user input must affect the command to be run, use the input only to make a selection from a predetermined set of safe commands. If the input appears to be malicious, the value passed to the command execution function should either default to some safe selection from this set or the program should decline to execute any command at all. 

In cases where user input must be used as an argument to a command executed by the program, this approach often becomes impractical because the set of legitimate argument values is too large or too hard to keep track of. Developers often fall back on blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. Any list of unsafe characters is likely to be incomplete and will be heavily dependant on the system where the commands are executed. A better approach is to create a white list of characters that are allowed to appear in the input and accept input composed exclusively of characters in the approved set.

An attacker can indirectly control commands executed by a program by modifying the environment in which they are executed. The environment should not be trusted and precautions should be taken to prevent an attacker from using some manipulation of the environment to perform an attack. Whenever possible, commands should be controlled by the application and executed using an absolute path. In cases where the path is not known at compile time, such as for cross-platform applications, an absolute path should be constructed from trusted values during execution. Command values and paths read from configuration files or the environment should be sanity-checked against a set of invariants that define valid values. 

Other checks can sometimes be performed to detect if these sources may have been tampered with. For example, if a configuration file is world-writable, the program might refuse to run. In cases where information about the binary to be executed is known in advance, the program may perform checks to verify the identity of the binary. If a binary should always be owned by a particular user or have a particular set of access permissions assigned to it, these properties can be verified programmatically before the binary is executed.

Although it may be impossible to completely protect a program from an imaginative attacker bent on controlling the commands the program executes, be sure to apply the principle of least privilege wherever the program executes an external command: do not hold privileges that are not essential to the execution of the command.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 77, 78</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Injection Flaws</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3570 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="9818E2BB-8E28-4CBE-88CD-DE8DF5EFF040" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The class &lt;Replace key="EnclosingClass.name"/&gt; is a singleton, so the member field &lt;Replace key="$dec.name$"/&gt; is shared between users.  The result is that one user could see another user's data.&lt;AltParagraph&gt;Servlet member fields might allow one user to see another user's data.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Many Servlet developers do not understand that, unless a Servlet implements the &lt;code&gt;SingleThreadModel&lt;/code&gt; interface, the Servlet is a singleton; there is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads. 

A common result of this misunderstanding is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.

&lt;b&gt;Example 1:&lt;/b&gt; The following Servlet stores the value of a request parameter in a member field and then later echoes the parameter value to the response output stream.

&lt;pre&gt;
public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req,
                       HttpServletResponse res) {
     name = req.getParameter("name");
     ...
     out.println(name + ", thanks for visiting!");
   }
}
&lt;/pre&gt;

While this code will work perfectly in a single-user environment, if two users access the Servlet at approximately the same time, it is possible for the two request handler threads to interleave in the following way:

	Thread 1:	assign "&lt;code&gt;Dick&lt;/code&gt;" to &lt;code&gt;name&lt;/code&gt;
	Thread 2:	assign "&lt;code&gt;Jane&lt;/code&gt;" to &lt;code&gt;name&lt;/code&gt;
	Thread 1:	print "&lt;code&gt;Jane, thanks for visiting!&lt;/code&gt;"
	Thread 2:	print "&lt;code&gt;Jane, thanks for visiting!&lt;/code&gt;"

 Thereby showing the first user the second user's name.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Do not use Servlet member fields for anything but constants. (i.e. make all member fields &lt;code&gt;static final&lt;/code&gt;).

Developers are often tempted to use Servlet member fields for user data when they need to transport data from one region of code to another. If this is your aim, consider declaring a separate class and using the Servlet only to "wrap" this new class. 

&lt;b&gt;Example 2:&lt;/b&gt; The bug in the example above can be corrected in the following way:

&lt;pre&gt;
public class GuestBook extends HttpServlet {

   protected void doPost (HttpServletRequest req,
                       HttpServletResponse res) {
	GBRequestHandler handler = new GBRequestHandler();
	handler.handle(req, res);
   }
}

public class GBRequestHandler {

   String name;

   public void handle(HttpServletRequest req,
                       HttpServletResponse res) {
     name = req.getParameter("name");
     ...
     out.println(name + ", thanks for visiting!");
   }

}
&lt;/pre&gt;

Alternatively, a Servlet can implement the &lt;code&gt;SingleThreadModel&lt;/code&gt; interface, in which case the Servlet container will maintain a pool of Servlet objects and dispatch a different object to process each request. Depending on the container implementation and the needs of the application, using the &lt;code&gt;SingleThreadModel&lt;/code&gt; interface may cause significant performance problems.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>The Java Servlet Specification</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/products/servlet/download.html</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 362, 488</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3630.1 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="798E4513-03B3-4252-A644-FBA596AEFB2B" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; sends unvalidated data to a web browser on line &lt;Replace key="PrimaryLocation.line"/&gt;, which can result in the browser executing malicious code.&lt;AltParagraph&gt;Sending unvalidated data to a web browser can result in the browser executing malicious code.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Cross-site scripting (XSS) vulnerabilities occur when:

1. Data enters a web application through an untrusted source, most frequently a web request or database.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;
2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. 
&lt;Paragraph&gt;
In this case the data is sent at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.

&lt;b&gt;Example 1:&lt;/b&gt; The following JSP code segment reads an employee ID, &lt;code&gt;eid&lt;/code&gt;, from an HTTP request and displays it to the user. 

&lt;pre&gt;
&amp;lt;% String eid = request.getParameter("eid"); %&amp;gt; 
...
Employee ID: &amp;lt;%= eid %&amp;gt;
&lt;/pre&gt;

The code in this example operates correctly if &lt;code&gt;eid&lt;/code&gt; contains only standard alphanumeric text. If &lt;code&gt;eid&lt;/code&gt; has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.

&lt;b&gt;Example 2:&lt;/b&gt; The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.

&lt;pre&gt; 
&amp;lt;%... 
 Statement stmt = conn.createStatement();
 ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
 if (rs != null) {
  rs.next(); 
  String name = rs.getString("name");
%&amp;gt;

Employee Name: &amp;lt;%= name %&amp;gt;
&lt;/pre&gt;

As in Example 1, this code functions correctly when the values of &lt;code&gt;name&lt;/code&gt; are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of &lt;code&gt;name&lt;/code&gt; is read from a database, whose contents are apparently managed by the application. However, if the value of &lt;code&gt;name&lt;/code&gt; originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Stored XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.

- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Stored XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.

- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.

Since XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. 

The most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. 

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:

In the content of a block-level element (in the middle of a paragraph of text):

- "&amp;lt;" is special because it introduces a tag.

- "&amp;amp;" is special because it introduces a character entity.

- "&amp;gt;" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening "&amp;lt;", but omitted it in error.

The following principles apply to attribute values:

- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.

- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.

- In attribute values without any quotes, white-space characters, such as space and tab, are special.

- "&amp;amp;" is special when used with certain attributes, because it introduces a character entity. 

In URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:

- Space, tab, and new line are special because they mark the end of the URL.

- "&amp;amp;" is special because it either introduces a character entity or separates CGI parameters.

- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.

- The "%" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, "%" must be filtered if input such as "%68%65%6C%6C%6F" becomes "hello" when it appears on the web page in question.


Within the body of a &amp;lt;SCRIPT&amp;gt; &amp;lt;/SCRIPT&amp;gt;:

- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. 

Server-side scripts:

- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (") on output might require additional filtering. 

Other possibilities:

- If an attacker submits a request in UTF-7, the special character '&amp;lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).

Once you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.

If input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].

Many application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>In Fortify Source Code Analysis Suite, the database is treated as a source of untrusted data for XSS vulnerabilities. If the database is a trusted resource in your environment, customize Audit Workbench to filter out data flow issues generated by database sources.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Understanding Malicious Content Mitigation for Web Developers</Title>
      <Publisher>CERT</Publisher>
      <Source>http://www.cert.org/tech_tips/malicious_code_mitigation.html#9</Source>
    </Reference>
    <Reference>
      <Title>HTML 4.01 Specification</Title>
      <Publisher>W3</Publisher>
      <Source>http://www.w3.org/TR/html4/sgml/entities.html#h-24.2</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 79, 80</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A4 Cross Site Scripting</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A1 Cross Site Scripting (XSS)</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3580 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="9C5BD1B5-C296-48d4-B5F5-5D2958661BC4" contentType="preformatted">
  <Abstract>&lt;Content&gt;Hardcoded passwords can compromise system security in a way that cannot be easily remedied.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.
&lt;Paragraph&gt;
In this case a hardcoded password was found in the call to &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code uses a hardcoded password to connect to a database:

&lt;pre&gt;
...
DriverManager.getConnection(url, "scott", "tiger");
...
&lt;/pre&gt;

This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the &lt;code&gt;javap -c&lt;/code&gt; command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:

&lt;pre&gt;
javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.

Some third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Avoid hardcoding passwords in source code and avoid using default passwords. If a hardcoded password is the default, require that it be changed and remove it from the source code.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword and FortifyNotPassword can be used to indicate which fields and variables represent passwords.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 259</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.3.1.3, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3340 CAT I, APP3350 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="6BD6C596-62D2-4ACE-B61F-9F8733AC2185" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; co-mingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.&lt;AltParagraph&gt;Commingling trusted and untrusted data in the same data structure encourages programmers to mistakenly trust unvalidated data.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary--to move from untrusted to trusted.

A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. The most common way to make this mistake is to allow trusted and untrusted data to commingle in the same data structure. 

&lt;Paragraph&gt;
In this case the untrusted data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. The data is added to what is generally used as a trusted data structure at the call to &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following Java code accepts an HTTP request and stores the &lt;code&gt;usrname&lt;/code&gt; parameter in the HTTP session object before checking to ensure that the user has been authenticated.

&lt;pre&gt;
usrname = request.getParameter("usrname");
if (session.getAttribute(ATTR_USR) == null) {
    session.setAttribute(ATTR_USR, usrname);
} 
&lt;/pre&gt;

Without well-established and maintained trust boundaries, programmers will inevitably lose track of which pieces of data have been validated and which have not. This confusion will eventually allow some data to be used without first being validated.
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Define clear trust boundaries in the application. Do not use the same data structure to hold trusted data in some contexts and untrusted data in other contexts. Minimize the number of ways that data can move across a trust boundary.

Trust boundary violations sometimes occur when input needs to be built up over a series of user interactions before being processed. It may not be possible to do complete input validation until all of the data has arrived. In these situations, it is still important to maintain a trust boundary. The untrusted data should be built up in a single untrusted data structure, validated, and then moved into a trusted location.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Do not feel that you need to find a "smoking gun" situation in which data that has not been validated is assumed to be trusted. If trust boundaries are not clearly delineated and respected, validation errors are inevitable. Instead of spending time searching for an exploitable scenario, concentrate on teaching programmers to create good trust boundaries.</Tip>
    <Tip>Most programs have trust boundaries that are defined by the semantics of the application. Consider writing custom rules to check for other places where user input crosses a trust boundary.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Writing Secure Code, Second Edition</Title>
      <Author>M. Howard, D. LeBlanc</Author>
      <Publisher>Microsoft Press</Publisher>
      <PublishedDate>2003</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 501</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3520 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="625EEE1F-464F-42DC-85D6-269A637EF747" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The class &lt;Replace key="EnclosingClass.name"/&gt; contains debug code, which can create unintended entry points in a deployed web application.&lt;AltParagraph&gt;Debug code can create unintended entry points in a deployed web application.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;A common development practice is to add "back door" code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the application. When this sort of debug code is accidentally left in the application, the application is open to unintended modes of interaction. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the application.

The most common example of forgotten debug code is a &lt;code&gt;main()&lt;/code&gt; method appearing in a web application. Although this is an acceptable practice during product development, classes that are part of a production J2EE application should not define a &lt;code&gt;main()&lt;/code&gt;.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Remove debug code before deploying a production version of an application. Regardless of whether a direct security threat can be articulated, it is unlikely that there is a legitimate reason for such code to remain in the application after the early stages of development.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>The presence of a &lt;code&gt;main()&lt;/code&gt; method may represent the tip of an iceberg. When you find a &lt;code&gt;main()&lt;/code&gt;, look for other indications that developers were rushed or otherwise not able to conclude their efforts normally.</Tip>
    <Tip>If you are auditing a non-J2EE Java application, the J2EE Bad Practices category might not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 489</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3620 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="CFD5D7C5-08EB-4D20-AE29-28C05CDA4B92" contentType="preformatted">
  <Abstract>&lt;Content&gt;Hardcoded passwords can compromise system security in a way that cannot be easily remedied.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.
&lt;Paragraph&gt;
In this case a hardcoded password was found in the call to &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code uses a hardcoded password to connect to a database:

&lt;pre&gt;
...
DriverManager.getConnection(url, "scott", "tiger");
...
&lt;/pre&gt;

This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the &lt;code&gt;javap -c&lt;/code&gt; command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:

&lt;pre&gt;
javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.

Some third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Avoid hardcoding passwords in source code and avoid using default passwords. If a hardcoded password is the default, require that it be changed and remove it from the source code.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword and FortifyNotPassword can be used to indicate which fields and variables represent passwords.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 259</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.3.1.3, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3340 CAT I, APP3350 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="9AB0476C-1D90-40DE-B4EA-C1420A8AC2F0" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The function &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; might reveal system data or debugging information by calling &lt;Replace key="PrimaryCall.name"/&gt; on line &lt;Replace key="PrimaryLocation.line"/&gt;.  The information revealed by &lt;Replace key="PrimaryCall.name"/&gt; could help an adversary form a plan of attack.&lt;AltParagraph&gt;Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.

&lt;Paragraph&gt;
In this case &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; is called in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code prints an exception to the standard error stream:

&lt;pre&gt;
try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}
&lt;/pre&gt;

Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Write error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).

Even brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an "Access Denied" message can reveal that a file or user exists on the system.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Do not rely on wrapper scripts, corporate IT policy, or quick-thinking system administrators to prevent system information leaks. Write software that is secure on its own.</Tip>
    <Tip>This category of vulnerability does not apply to all types of programs. For example, if your application executes on a client machine where system information is already available to an attacker, or if you print system information only to a trusted log file, you can use AuditGuide to filter out this category.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 497</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3620 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="E1B32227-C0BD-4A57-9C34-6794D9089A21" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Attackers can control an argument to the reflection method &lt;Replace key="PrimaryCall.name"/&gt; at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt;, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.&lt;AltParagraph&gt;An attacker might be able to create unexpected control flow paths through the application, potentially bypassing security checks.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner. Even the ability to control the arguments passed to a given method or constructor may give a wily attacker the edge necessary to mount a successful attack. 

This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the application's classpath or add new entries to the application's classpath. Under either of these conditions, the attacker can use reflection to introduce new, presumably malicious, behavior into the application.
&lt;Paragraph&gt;
In this case the untrusted data enters the program at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. It is passed to the reflection API at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
&lt;b&gt;Example:&lt;/b&gt; A common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a command dispatcher that does not use reflection:

&lt;pre&gt;
String ctl = request.getParameter("ctl");
Worker ao = null;
if (ctl.equals("Add")) {
  ao = new AddCommand();
} else if (ctl.equals("Modify")) {
  ao = new ModifyCommand();
} else {
  throw new UnknownActionError();
}
ao.doAction(request);
&lt;/pre&gt;

A programmer might refactor this code to use reflection as follows:

&lt;pre&gt;
    String ctl = request.getParameter("ctl");
    Class cmdClass = Class.forName(ctl + "Command");
    Worker ao = (Worker) cmdClass.newInstance();
    ao.doAction(request);
&lt;/pre&gt;

The refactoring initially appears to offer a number of advantages. There are fewer lines of code, the &lt;code&gt;if/else&lt;/code&gt; blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher.

However, the refactoring allows an attacker to instantiate any object that implements the &lt;code&gt;Worker&lt;/code&gt; interface. If the command dispatcher is still responsible for access control, then whenever programmers create a new class that implements the &lt;code&gt;Worker&lt;/code&gt; interface, they must remember to modify the dispatcher's access control code. If they fail to modify the access control code, then some &lt;code&gt;Worker&lt;/code&gt; classes will not have any access control.

One way to address this access control problem is to make the &lt;code&gt;Worker&lt;/code&gt; object responsible for performing the access control check. An example of the re-refactored code follows:

&lt;pre&gt;
String ctl = request.getParameter("ctl");
Class cmdClass = Class.forName(ctl + "Command");
Worker ao = (Worker) cmdClass.newInstance();
&lt;b&gt;ao.checkAccessControl(request);&lt;/b&gt;
ao.doAction(request);
&lt;/pre&gt;

Although this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes.

This code also highlights another security problem with using reflection to build a command dispatcher. An attacker can invoke the default constructor for any kind of object. In fact, the attacker is not even constrained to objects that implement the &lt;code&gt;Worker&lt;/code&gt; interface; the default constructor for any object in the system can be invoked. If the object does not implement the &lt;code&gt;Worker&lt;/code&gt; interface, a &lt;code&gt;ClassCastException&lt;/code&gt; will be thrown before the assignment to &lt;code&gt;ao&lt;/code&gt;, but if the constructor performs operations that work in the attacker's favor, the damage will already have been done. Although this scenario is relatively benign in simple applications, in larger applications where complexity grows exponentially it is not unreasonable that an attacker could find a constructor to leverage as part of an attack. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The best way to prevent unsafe reflection is with a level of indirection: create a list of legitimate names that users are allowed to specify, and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a name that is passed to the reflection API.

Reflection can also be used to create a custom data-driven architecture, whereby a configuration file determines the types and combinations of objects that are used by the application. This style of programming introduces the following security concerns:

- The configuration file that controls the program is an essential part of the program's source code and must be protected and reviewed accordingly.

- Because the configuration file is unique to the application, unique work must be performed to evaluate the security of the design.

- Because the semantics of the application are now governed by a configuration file with a custom format, custom rules are required for obtaining optimal static analysis results.

For these reasons, avoid using this style of design unless your team can devote a large amount of effort to security evaluation.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Beware of attempts to validate user input before using it as part of a call to a reflection method. Because the application is likely to evolve faster than the operating system, the file system, or other system components, the work required to validate user input must evolve much more rapidly than the input validation required for sending user data to other system components. Even if the validation is currently correct, it might not be correct in the future.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 470</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A4 Insecure Direct Object Reference</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3570 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="DD48C0E5-3651-4DF1-9BE8-EB989C64E33A" contentType="preformatted">
  <Abstract>&lt;Content&gt;Hardcoded passwords can compromise system security in a way that cannot be easily remedied.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.
&lt;Paragraph&gt;
In this case a hardcoded password was found in the call to &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code uses a hardcoded password to connect to a database:

&lt;pre&gt;
...
DriverManager.getConnection(url, "scott", "tiger");
...
&lt;/pre&gt;

This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the &lt;code&gt;javap -c&lt;/code&gt; command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:

&lt;pre&gt;
javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.

Some third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Avoid hardcoding passwords in source code and avoid using default passwords. If a hardcoded password is the default, require that it be changed and remove it from the source code.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword and FortifyNotPassword can be used to indicate which fields and variables represent passwords.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 259</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.3.1.3, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3340 CAT I, APP3350 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="7F7E0FDE-A69E-4F6F-91DB-F75A45091CC1" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; stores a non-serializable object as an &lt;code&gt;HttpSession&lt;/code&gt; attribute, which can damage application reliability.&lt;AltParagraph&gt;Storing a non-serializable object as an &lt;code&gt;HttpSession&lt;/code&gt; attribute can damage application reliability.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an &lt;code&gt;HttpSession&lt;/code&gt; object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application.

In order for session replication to work, the values the application stores as attributes in the session must implement the &lt;code&gt;Serializable&lt;/code&gt; interface. 

&lt;b&gt;Example 1:&lt;/b&gt; The following class adds itself to the session, but because it is not serializable, the session can no longer be replicated.

&lt;pre&gt;
public class DataGlob {
   String globName;
   String globValue;

   public void addToSession(HttpSession session) {
     session.setAttribute("glob", this);
   }
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;In many cases, the easiest way to fix this problem is simply to have the offending object implement the &lt;code&gt;Serializable&lt;/code&gt; interface. 

&lt;b&gt;Example 2:&lt;/b&gt; The code in Example 1 could be rewritten in the following way:

&lt;pre&gt;
public class DataGlob implements java.io.Serializable {
   String globName;
   String globValue;

   public void addToSession(HttpSession session) {
     session.setAttribute("glob", this);
   }
}
&lt;/pre&gt;

Note that for complex objects, the transitive closure of the objects stored in the session must be serializable. If object A references object B and object A is stored in the session, then both A and B must implement &lt;code&gt;Serializable&lt;/code&gt;.

While implementing the &lt;code&gt;Serializable&lt;/code&gt; interface is often easy (since the interface does not force the class to define any methods), some types of objects will cause complications. Watch out for objects that hold references to external resources. For example, both streams and JNI are likely to cause complications.

&lt;b&gt;Example 3:&lt;/b&gt; Use type checking to require serializable objects. Instead of this:

&lt;pre&gt;
public static void addToSession(HttpServletRequest req,
                     String attrib, Object obj)
{
  HttpSession sess = req.getSession(true);
  sess.setAttribute(attrib, obj);
}
&lt;/pre&gt;

write this:

&lt;pre&gt;
public static void addToSession(HttpServletRequest req,
                     String attrib, Serializable ser) {
  HttpSession sess = req.getSession(true);
  sess.setAttribute(attrib, ser);
}
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>The Java Servlet Specification</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/products/servlet/download.html</Source>
    </Reference>
    <Reference>
      <Title>The java.io.Serializable Interface</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2se/1.4.2/docs/api/java/io/Serializable.html</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 579</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A3 Broken Authentication and Session Management</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A7 Broken Authentication and Session Management</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.3</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.7</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
  </References>
</Description>
<Description classID="B32F92AC-9605-0987-E73B-CCB28279AA24" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can crash the program by dereferencing a null pointer on line &lt;Replace key="PrimaryLocation.line"/&gt;.&lt;AltParagraph&gt;The program can potentially dereference a null pointer, thereby causing a null pointer exception.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Null pointer exceptions usually occur when one or more of the programmer's assumptions is violated. A dereference-after-store error occurs when a program explicitly sets an object to null and dereferences it later. This error is often the result of a programmer initializing a variable to null when it is declared.

&lt;Paragraph&gt;
In this case, the variable can be null when it is dereferenced at line &lt;Replace key="PrimaryLocation.line"/&gt;, thereby causing a null pointer exception. 
&lt;/Paragraph&gt;
Most null pointer issues result in general software reliability problems, but if attackers can intentionally trigger a null pointer dereference, they can use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.
 
&lt;b&gt;Example:&lt;/b&gt; In the following code, the programmer explicitly sets the variable &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;. Later, the programmer dereferences &lt;code&gt;foo&lt;/code&gt; before checking the object for a null value.

&lt;pre&gt;
Foo foo = null;
...
foo.setBar(val);
...
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Implement careful checks before dereferencing objects that might be null. When possible, abstract null checks into wrappers around code that manipulates resources to ensure that they are applied in all cases and to minimize the places where mistakes can occur.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 476</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="EDD8E0B5-D8F2-4F56-A20B-549E3880318B" contentType="preformatted">
  <Abstract>&lt;Content&gt;The J2EE standard forbids the direct management of connections.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The J2EE standard requires that applications use the container's resource management facilities to obtain connections to resources. 

For example, a J2EE application should obtain a database connection as follows:

&lt;pre&gt;
ctx = new InitialContext();
datasource = (DataSource)ctx.lookup(DB_DATASRC_REF);
conn = datasource.getConnection();
&lt;/pre&gt;

and should avoid obtaining a connection in this way:

&lt;pre&gt;
conn = DriverManager.getConnection(CONNECT_STRING);
&lt;/pre&gt;

Every major web application container provides pooled database connection management as part of its resource management framework. Duplicating this functionality in an application is difficult and error prone, which is part of the reason it is forbidden under the J2EE standard.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Replace direct calls to &lt;code&gt;DriverManager.getConnection()&lt;/code&gt; with a JNDI lookup of the appropriate connection factory, and obtain a connection from the connection factory. &lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Depending upon the complexity of resource management scheme in use, it may be difficult to identify specific errors in a proprietary connection management infrastructure. Instead of trying to hunt down the bugs, advocate migrating the application to a connection pool manager provided by the container.</Tip>
    <Tip>Beyond the more vanilla performance problems that are likely to be introduced, proprietary connection management often leads to password management mistakes. In applications that manage their own database connections it is not uncommon to find passwords hard-coded or stored in plaintext configuration files because no alternative is readily available. Examples of this type of behavior should serve as added ammunition in your argument for moving to an application server managed connection pool.</Tip>
    <Tip>If you are auditing a non-J2EE Java application, the J2EE Bad Practices categories may not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Java 2 Platform Enterprise Edition Specification, v1.4</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2ee/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 245</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="9C96C95D-D448-4B86-940D-D0371E42CB88" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; mishandles confidential information, which can compromise user privacy and is often illegal.&lt;AltParagraph&gt;Mishandling private information, such as customer passwords or social security numbers, can compromise user privacy and is often illegal. &lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Privacy violations occur when:

1. Private user information enters the program.
&lt;Paragraph&gt;
    In this case the data comes from &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;.
&lt;/Paragraph&gt;
2. The data is written to an external location, such as the console, file system, or network. 
&lt;Paragraph&gt;
    In this case the data is passed to &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the &lt;code&gt;getPassword()&lt;/code&gt; function returns the user-supplied plaintext password associated with the account. 

&lt;pre&gt;
pass = getPassword();
...
dbmsLog.println(id+":"+pass+":"+type+":"+tstamp);
&lt;/pre&gt;

The code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. 

Private data can enter a program in a variety of ways:

- Directly from the user in the form of a password or personal information

- Accessed from a database or other data store by the application

- Indirectly from a partner or other third party

Sometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. 

Security and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. 

Although there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].

In response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:

- Safe Harbor Privacy Framework [3]

- Gramm-Leach Bliley Act (GLBA) [4]

- Health Insurance Portability and Accountability Act (HIPAA) [5]

- California SB-1386 [6]

Despite these regulations, privacy violations continue to occur with alarming frequency. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;When security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.

To enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.

The best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>As part of any thorough audit for privacy violations, ensure that custom rules have been written to identify all sources of private or otherwise sensitive information entering the program.  Most sources of private data cannot be identified automatically.  Without custom rules, your check for privacy violations is likely to be substantially incomplete.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword, FortifyNotPassword, FortifyPrivate and FortifyNotPrivate can be used to indicate which fields and variables represent passwords and private data.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>AOL man pleads guilty to selling 92m email addies</Title>
      <Author>J. Oates</Author>
      <Publisher>The Register</Publisher>
      <PublishedDate>2005</PublishedDate>
      <Source>http://www.theregister.co.uk/2005/02/07/aol_email_theft/</Source>
    </Reference>
    <Reference>
      <Title>Privacy Initiatives</Title>
      <Publisher>U.S. Federal Trade Commission</Publisher>
      <Source>http://www.ftc.gov/privacy/</Source>
    </Reference>
    <Reference>
      <Title>Safe Harbor Privacy Framework</Title>
      <Publisher>U.S. Department of Commerce</Publisher>
      <Source>http://www.export.gov/safeharbor/</Source>
    </Reference>
    <Reference>
      <Title>Financial Privacy: The Gramm-Leach Bliley Act (GLBA)</Title>
      <Publisher>Federal Trade Commission</Publisher>
      <Source>http://www.ftc.gov/privacy/glbact/index.html</Source>
    </Reference>
    <Reference>
      <Title>Health Insurance Portability and Accountability Act (HIPAA)</Title>
      <Publisher>U.S. Department of Human Services</Publisher>
      <Source>http://www.hhs.gov/ocr/hipaa/</Source>
    </Reference>
    <Reference>
      <Title>California SB-1386</Title>
      <Publisher>Government of the State of California</Publisher>
      <PublishedDate>2002</PublishedDate>
      <Source>http://info.sen.ca.gov/pub/01-02/bill/sen/sb_1351-1400/sb_1386_bill_20020926_chaptered.html</Source>
    </Reference>
    <Reference>
      <Title>Writing Secure Code, Second Edition</Title>
      <Author>M. Howard, D. LeBlanc</Author>
      <Publisher>Microsoft Press</Publisher>
      <PublishedDate>2003</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 359</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.2, 3.4, 4.2, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.2, 3.4, 4.2, 6.5.6, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3310 CAT I, APP3340 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="9B5F0161-88EC-4104-B70B-0182FEB53BF2" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;On line &lt;Replace key="PrimaryLocation.line"/&gt; of &lt;Replace key="PrimaryLocation.file"/&gt;, the method &lt;Replace key="EnclosingFunction.name"/&gt; invokes a SQL query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.&lt;AltParagraph&gt;Constructing a dynamic SQL statement with user input could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. &lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;SQL injection errors occur when:

1. Data enters a program from an untrusted source.

&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;

2. The data is used to dynamically construct a SQL query. 

&lt;Paragraph&gt;
In this case the data is passed to &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt; The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. 

&lt;pre&gt;
...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE owner = '" 
				+ userName + "' AND itemname = '"  
				+ itemName + "'";
	ResultSet rs = stmt.execute(query);
	...
&lt;/pre&gt;

The query that this code intends to execute follows:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = &amp;lt;userName&amp;gt;
	AND itemname = &amp;lt;itemName&amp;gt;;
&lt;/pre&gt;

However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if &lt;code&gt;itemName&lt;/code&gt; does not contain a single-quote character. If an attacker with the user name &lt;code&gt;wiley&lt;/code&gt; enters the string "&lt;code&gt;name' OR 'a'='a&lt;/code&gt;" for &lt;code&gt;itemName&lt;/code&gt;, then the query becomes the following:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';
&lt;/pre&gt;

The addition of the &lt;code&gt;OR 'a'='a'&lt;/code&gt; condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:

&lt;pre&gt;
	SELECT * FROM items;
&lt;/pre&gt;

This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the &lt;code&gt;items&lt;/code&gt; table, regardless of their specified owner.

&lt;b&gt;Example 2:&lt;/b&gt; This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name &lt;code&gt;wiley&lt;/code&gt; enters the string "&lt;code&gt;name'; DELETE FROM items; --&lt;/code&gt;" for &lt;code&gt;itemName&lt;/code&gt;, then the query becomes the following two queries:

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'
&lt;/pre&gt;

Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database. 

Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "&lt;code&gt;name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a&lt;/code&gt;", the following three valid statements will be created: 

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';
&lt;/pre&gt;

One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:

- Target fields that are not quoted

- Find ways to bypass the need for certain escaped meta-characters

- Use stored procedures to hide the injected meta-characters

Manually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. 

Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.

The previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:

&lt;pre&gt;
...
String userName = ctx.getAuthenticatedUserName();
String itemName = request.getParameter("itemName");
String query =
 	       "SELECT * FROM items WHERE itemname=? AND owner=?"; 
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, itemName);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;

More complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the &lt;code&gt;WHERE&lt;/code&gt; clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. 
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>A common mistake is to use parameterized SQL statements that are constructed by concatenating user-controlled strings. Of course, this defeats the purpose of using parameterized SQL statements. If you are not certain that the strings used to form parameterized statements are constants controlled by the application, do not assume that they are safe because they are not being executed directly as SQL strings. Thoroughly investigate all uses of user-controlled strings in SQL statements and verify that none can be used to modify the meaning of the query. </Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>SQL Injection Attacks by Example</Title>
      <Author>S. J. Friedl</Author>
      <Source>http://www.unixwiz.net/techtips/sql-injection.html</Source>
    </Reference>
    <Reference>
      <Title>Stop SQL Injection Attacks Before They Stop You</Title>
      <Author>P. Litwin</Author>
      <Publisher>MSDN Magazine</Publisher>
      <PublishedDate>2004</PublishedDate>
      <Source>http://msdn.microsoft.com/msdnmag/issues/04/09/SQLInjection/default.aspx</Source>
    </Reference>
    <Reference>
      <Title>SQL Injection and Oracle, Part One</Title>
      <Author>P. Finnigan</Author>
      <Publisher>Security Focus</Publisher>
      <PublishedDate>2002</PublishedDate>
      <Source>http://www.securityfocus.com/infocus/1644</Source>
    </Reference>
    <Reference>
      <Title>Writing Secure Code, Second Edition</Title>
      <Author>M. Howard, D. LeBlanc</Author>
      <Publisher>Microsoft Press</Publisher>
      <PublishedDate>2003</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 89</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Injection Flaws</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3540.1 CAT, APP3540.3 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="1834C857-2848-41F2-98F7-D5C5F157E729" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The declaration of &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="EnclosingClass.name"/&gt; fails to compare its parameter with null, which is a violation of the method's contract.&lt;AltParagraph&gt;This function violates the contract that it must compare its parameter with null.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The Java standard requires that implementations of &lt;code&gt;Object.equals()&lt;/code&gt;, &lt;code&gt;Comparable.compareTo()&lt;/code&gt;, and &lt;code&gt;Comparator.compare()&lt;/code&gt; must return a specified value if their parameters are null. Failing to follow this contract may result in unexpected behavior.

&lt;b&gt;Example 1:&lt;/b&gt; The following implementation of the &lt;code&gt;equals()&lt;/code&gt; method does not compare its parameter with null. 

&lt;pre&gt;
public boolean equals(Object object)
{
   return (toString().equals(object.toString()));
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Always follow the contract that &lt;code&gt;Object.equals()&lt;/code&gt; must return null if it receives a null parameter. 

&lt;b&gt;Example 1 Revisited:&lt;/b&gt; The following code has been rewritten to explicitly check for a null argument and return false if one is found. 

&lt;pre&gt;
public boolean equals(Object object)
{
   if (object == null) 
	return false;
   return (toString().equals(object.toString()));
}
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 398</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="898621C4-B672-43E6-AAB5-317A3D12D274" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The class &lt;Replace key="EnclosingClass.name"/&gt; stores a database connection in a static field, which creates a race condition when the connection is shared between threads.&lt;AltParagraph&gt;Database connections stored in static fields will be shared between threads.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;A transactional resource object such as database connection can only be associated with one transaction at a time. For this reason, a connection should not be shared between threads and should not be stored in a static field. See Section 4.2.3 of the J2EE Specification for more details.

&lt;b&gt;Example 1:&lt;/b&gt; 

&lt;pre&gt;
public class ConnectionManager {

private static Connection conn = initDbConn();
...
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Rather than storing the database connection in a static field, use a connection pool to cache connection objects. Most modern J2EE and Servlet containers provide built-in connection pooling facilities.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>If you are auditing a non-J2EE Java application, this category may not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Java 2 Platform Enterprise Edition Specification, v1.4</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/j2ee/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 362, 567</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>APP3630.1 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="771E5717-2B4D-64FC-9A63-E16701E24D0D" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can crash the program by dereferencing a null pointer on line &lt;Replace key="PrimaryLocation.line"/&gt;.&lt;AltParagraph&gt;The program can dereference a null pointer, thereby causing a null pointer exception.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Null pointer exceptions usually occur when one or more of the programmer's assumptions is violated. Specifically, dereference-after-check errors occur when a program makes an explicit check for null, but proceeds to dereference the object when it is known to be null. Errors of this type are often the result of a typo or programmer oversight. 
&lt;Paragraph&gt;
In this case the variable can be null when it is dereferenced at line &lt;Replace key="PrimaryLocation.line"/&gt;, thereby causing a null pointer exception. 
&lt;/Paragraph&gt;
Most null pointer issues result in general software reliability problems, but if attackers can intentionally cause the program to dereference a null pointer, they can use the resulting exception to mount a denial of service attack or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.

&lt;b&gt;Example 1:&lt;/b&gt; In the following code, the programmer confirms that the variable &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and subsequently dereferences it erroneously. If &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; when it is checked in the &lt;code&gt;if&lt;/code&gt; statement, then a null dereference will occur, thereby causing a null pointer exception. 

&lt;pre&gt;
if (foo == null) {
	foo.setBar(val);
	...
}
&lt;/pre&gt;

&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Implement careful checks before dereferencing objects that might be null. When possible, abstract null checks into wrappers around code that manipulates resources to ensure that they are applied in all cases and to minimize the places where mistakes can occur.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 476</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="85E603E0-2933-4F38-851F-341604F75CB9" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The catch block at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt; handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.&lt;AltParagraph&gt;The catch block handles a broad swath of exceptions, potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Multiple catch blocks can get ugly and repetitive, but "condensing" catch blocks by catching a high-level class like &lt;code&gt;Exception&lt;/code&gt; can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.

&lt;b&gt;Example:&lt;/b&gt; The following code excerpt handles three types of exceptions in an identical fashion.

&lt;pre&gt;
  try {
    doExchange();
  }
  catch (IOException e) {
    logger.error("doExchange failed", e);
  }
  catch (InvocationTargetException e) {
    logger.error("doExchange failed", e);
  }
  catch (SQLException e) {
    logger.error("doExchange failed", e);
  }
&lt;/pre&gt;

At first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:

&lt;pre&gt;
  try {
    doExchange();
  }
  catch (Exception e) {
    logger.error("doExchange failed", e);
  }
&lt;/pre&gt;

However, if &lt;code&gt;doExchange()&lt;/code&gt; is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from &lt;code&gt;RuntimeException&lt;/code&gt; such as &lt;code&gt;ClassCastException&lt;/code&gt;, and &lt;code&gt;NullPointerException&lt;/code&gt;, which is not the programmer's intent.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Do not catch broad exception classes like &lt;code&gt;Exception&lt;/code&gt;, &lt;code&gt;Throwable&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt;, or &amp;lt;RuntimeException&amp;gt; except at the very top level of the program or thread.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Fortify will not flag an overly broad catch block if the catch block in question immediately throws a new exception.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 396</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A7 Improper Error Handling</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.7</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.2, 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3120 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="EC71C442-6E66-45DF-9890-41A5156B1CD0" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The function &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; sometimes fails to release a system resource allocated by &lt;Replace key="FirstTransitionFunction"/&gt; on line &lt;Replace key="FirstTraceLocation.line"/&gt;.&lt;AltParagraph&gt;The program can potentially fail to release a system resource.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The program can potentially fail to release a system resource.
&lt;Paragraph&gt;
    In this case, there are program paths on which the resource allocated in &lt;Replace key="FirstTraceLocation.file"/&gt; at line &lt;Replace key="FirstTraceLocation.line"/&gt; is not released.
&lt;/Paragraph&gt;

Resource leaks have at least two common causes:

- Error conditions and other exceptional circumstances.

- Confusion over which part of the program is responsible for releasing the resource.

Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.

&lt;b&gt;Example 1:&lt;/b&gt; The following method never closes the file handle it opens. The &lt;code&gt;finalize()&lt;/code&gt; method for &lt;code&gt;FileInputStream&lt;/code&gt; eventually calls &lt;code&gt;close()&lt;/code&gt;, but there is no guarantee as to how long it will take before the &lt;code&gt;finalize()&lt;/code&gt; method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.

&lt;pre&gt;
private void processFile(String fName) throws FileNotFoundException, IOException
{
  FileInputStream fis = new FileInputStream(fName);
  int sz;
  byte[] byteArray = new byte[BLOCK_SIZE];
  while ((sz = fis.read(byteArray)) != -1) {
    processBytes(byteArray, sz);
  }
}
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.

&lt;pre&gt;
  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;1. Never rely on &lt;code&gt;finalize()&lt;/code&gt; to reclaim resources. In order for an object's &lt;code&gt;finalize()&lt;/code&gt; method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's &lt;code&gt;finalize()&lt;/code&gt; method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to "bursty" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.

Finally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the &lt;code&gt;finalize()&lt;/code&gt; method will hang. 

2. Release resources in a &lt;code&gt;finally&lt;/code&gt; block. The code for Example 2 should be rewritten as follows:

&lt;pre&gt;
  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}
&lt;/pre&gt;

This solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. 

Also, the &lt;code&gt;execCxnSql&lt;/code&gt; method does not initialize the &lt;code&gt;stmt&lt;/code&gt; object to null. Instead, it checks to ensure that &lt;code&gt;stmt&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; before calling &lt;code&gt;safeClose()&lt;/code&gt;. Without the &lt;code&gt;null&lt;/code&gt; check, the Java compiler reports that &lt;code&gt;stmt&lt;/code&gt; might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  &lt;code&gt;stmt&lt;/code&gt; is initialized to &lt;code&gt;null&lt;/code&gt; in a more complex method, cases in which &lt;code&gt;stmt&lt;/code&gt; is used without being initialized will not be detected by the compiler. 
&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 404</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The function &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; might reveal system data or debugging information by calling &lt;Replace key="PrimaryCall.name"/&gt; on line &lt;Replace key="PrimaryLocation.line"/&gt;.  The information revealed by &lt;Replace key="PrimaryCall.name"/&gt; could help an adversary form a plan of attack.&lt;AltParagraph&gt;Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.

&lt;Paragraph&gt;
In this case &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; is called in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code prints an exception to the standard error stream:

&lt;pre&gt;
try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}
&lt;/pre&gt;

Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the search path could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Write error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Be careful, debugging traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).

Even brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an "Access Denied" message can reveal that a file or user exists on the system.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Do not rely on wrapper scripts, corporate IT policy, or quick-thinking system administrators to prevent system information leaks. Write software that is secure on its own.</Tip>
    <Tip>This category of vulnerability does not apply to all types of programs. For example, if your application executes on a client machine where system information is already available to an attacker, or if you print system information only to a trusted log file, you can use AuditGuide to filter out this category.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 497</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3620 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="78E0700E-56FE-45A2-A11B-6A560F730576" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The form post at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt; must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.&lt;AltParagraph&gt;Form posts must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;
A cross-site request forgery (CSRF) vulnerability occurs when:
1. A Web application uses session cookies.

2. The application acts on an HTTP request without verifying that the request was made with the user's consent.

&lt;Paragraph&gt;
In this case the application generates HTTP request via a form post at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application.)  This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests.  Imagine a Web application that allows administrators to create new accounts by submitting this form:

&lt;pre&gt;
&amp;lt;form method="POST" action="/new_user" &amp;gt;
  Name of new user: &amp;lt;input type="text" name="username"&amp;gt;
  Password for new user: &amp;lt;input type="password" name="user_passwd"&amp;gt;
    &amp;lt;input type="submit" name="action" value="Create User"&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/pre&gt;

An attacker might set up a Web site with the following:

&lt;pre&gt;
&amp;lt;form method="POST" action="http://www.example.com/new_user"&amp;gt;
  &amp;lt;input type="hidden" name="username" value="hacker"&amp;gt;
  &amp;lt;input type="hidden" name="user_passwd" value="hacked"&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;script&amp;gt;
  document.usr_form.submit();
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

If an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request.  Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.

Most Web browsers send an HTTP header named &lt;code&gt;referer&lt;/code&gt; along with each request. The &lt;code&gt;referer&lt;/code&gt; header is supposed to contain the URL of the referring page, but attackers can forge it, so the referer header is not useful for determining the provenance of a request.

Applications that pass the session identifier on the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.

CSRF is entry number five on the 2007 OWASP Top 10 list.

&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;
Applications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier on the form, like this:

&lt;pre&gt;
&amp;lt;form method="POST" action="/new_user" &amp;gt;
  Name of new user: &amp;lt;input type="text" name="username"&amp;gt;
  Password for new user: &amp;lt;input type="password" name="user_passwd"&amp;gt;
    &amp;lt;input type="submit" name="action" value="Create User"&amp;gt;
&amp;lt;/form&amp;gt;
    &amp;lt;input type="hidden" name="req_id" value="87ae34d92ba7a1"&amp;gt;
&lt;/pre&gt;

Then the back-end logic can validate the request identifier before processing the rest of the form data. The request identifier can be unique to each new form or can be shared across every form for a particular session.  As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>SCA flags all HTML forms and XMLHttpRequest objects that might perform a POST operation.  The auditor must determine if each form could be valuable to an attacker as a CSRF target and whether or not an appropriate mitigation technique is in place. </Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</Title>
      <Author>A. Klein</Author>
      <Source>http://www.packetstormsecurity.org/papers/general/whitepaper_httpresponse.pdf</Source>
    </Reference>
    <Reference>
      <Title>2007 OWASP Top 10</Title>
      <Author>OWASP</Author>
      <Source>http://www.owasp.org/index.php/Top_10_2007</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 352</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A5 Cross Site Request Forgery (CSRF)</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.5</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
  </References>
</Description>
<Description classID="B7ED276F-524D-444B-8930-7D77535BF0D0" contentType="preformatted">
  <Abstract>&lt;Content&gt;An overly long session timeout gives attackers more time to potentially compromise user accounts.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The longer a session stays open, the larger the window of opportunity an attacker has to compromise user accounts. While a session remains active, an attacker might be able to brute force a user's password, crack a user's wireless encryption key, or commandeer a session from an open browser. Longer session timeouts can also prevent memory from being released and eventually result in a denial of service if a sufficiently large number of sessions are created.

&lt;b&gt;Example 1:&lt;/b&gt; If the session timeout is zero or less than zero, the session never expires. The following example shows a session timeout set to -1, which will cause the session to remain active indefinitely.
&lt;pre&gt;
&amp;lt;session-config&amp;gt;
    &amp;lt;session-timeout&amp;gt;-1&amp;lt;/session-timeout&amp;gt;
&amp;lt;/session-config&amp;gt;
&lt;/pre&gt;

The &lt;code&gt;&amp;lt;session-timeout&amp;gt;&lt;/code&gt; tag defines the default session timeout interval for all sessions in the web application. If the &lt;code&gt;&amp;lt;session-timeout&amp;gt;&lt;/code&gt; tag is missing, it is left to the container to set the default timeout.

            
This category is from the Cigital Java Rulepack. http://www.cigital.com/securitypack/&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Set a session timeout that is 30 minutes or less, which both allows users to interact with the application over a period of time and provides a reasonable bound for the window of attack.

&lt;b&gt;Example 2:&lt;/b&gt; The following example sets the session timeout to 20 minutes.
&lt;pre&gt;
&amp;lt;session-config&amp;gt;
  &amp;lt;session-timeout&amp;gt;20&amp;lt;/session-timeout&amp;gt;
&amp;lt;/session-config&amp;gt;
&lt;/pre&gt;
            &lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Java Servlet Specification 2.4</Title>
      <Author>Sun Microsystems, Inc.</Author>
      <Source>http://java.sun.com/products/servlet/index.jsp</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 613</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A3 Broken Authentication and Session Management</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A7 Broken Authentication and Session Management</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.3, 8.5.15</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.7, 8.5.15</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3415 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="8BA3B029-5DB0-434D-B202-D31FF2B64665" contentType="preformatted">
  <Abstract>&lt;Content&gt;A Servlet defined in &lt;code&gt;web.xml&lt;/code&gt; cannot be accessed without a corresponding servlet mapping.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The absence of a valid servlet mapping prevents all access to the unmapped servlet.

&lt;Paragraph&gt;In this case, the servlet defined at line &lt;Replace key="PrimaryLocation.line"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; does not have a corresponding servlet mapping.&lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt; The following entry from &lt;code&gt;web.xml&lt;/code&gt; defines &lt;code&gt;ExampleServlet&lt;/code&gt; but fails to define a corresponding servlet mapping.
&lt;pre&gt;
&amp;lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4"&amp;gt;

    &amp;lt;servlet&amp;gt;
      &amp;lt;servlet-name&amp;gt;ExampleServlet&amp;lt;/servlet-name&amp;gt;
      &amp;lt;servlet-class&amp;gt;com.class.ExampleServlet&amp;lt;/servlet-class&amp;gt;
      &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

&amp;lt;/web-app&amp;gt;
&lt;/pre&gt;
            
This category was derived from the Cigital Java Rulepack. http://www.cigital.com/securitypack/&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Ensure that every &lt;code&gt;&amp;lt;servlet&amp;gt;&lt;/code&gt; has a corresponding &lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;.

&lt;b&gt;Example 2:&lt;/b&gt;  The following entry from &lt;code&gt;web.xml&lt;/code&gt; defines &lt;code&gt;ExampleServlet&lt;/code&gt; and a corresponding servlet mapping.
&lt;pre&gt;
&amp;lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4"&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;ExampleServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;com.class.ExampleServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;ExampleServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/exampleservlet&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;action&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/action&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/pre&gt;
 &lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Java Servlet Specification 2.4</Title>
      <Author>Sun Microsystems, Inc.</Author>
      <Source>http://java.sun.com/products/servlet/index.jsp</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 730</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F" contentType="preformatted">
  <Abstract>&lt;Content&gt;Hardcoded passwords can compromise system security in a way that cannot be easily remedied.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.
&lt;Paragraph&gt;
In this case the hardcoded password appears in the comment in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following comment specifies the default password to connect to a database:

&lt;pre&gt;
...
// Default username for database connection is "scott" 
// Default password for database connection is "tiger"
...
&lt;/pre&gt;

This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system.
            &lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.
            &lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Avoid hardcoding passwords in source code and avoid using default passwords. If a hardcoded password is the default, require that it be changed and remove it from the source code.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 615</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.3.1.3, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3340 CAT I, APP3350 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="C15A1F06-3B47-4AA2-AFD1-02E895160582" contentType="preformatted">
  <Abstract>&lt;Content&gt;The SOAP Monitor module allows attackers to sniff SOAP traffic.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Apache Axis 2 provides developers with a utility to monitor incoming and outgoing SOAP messages through a Java applet. The SOAP Monitor will show all SOAP messages used to invoke a Web Service.  Attackers can use the utility to eavesdrop on traffic between a Web Service and its clients.

&lt;Paragraph&gt;
In this case, &lt;Replace key="PrimaryLocation.file"/&gt; contains references to the SOAP Monitor utility at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Disable the SOAP Monitor by removing references to it from your configuration files. Specifically, ensure that &lt;code&gt;web.xml&lt;/code&gt; does not contain a servlet or servlet-mapping to the SOAP Monitor service. Also make sure that &lt;code&gt;axis2.xml&lt;/code&gt; has no references like &lt;code&gt;&amp;lt;module ref=&amp;quot;soapmonitor&amp;quot;/&amp;gt;&lt;/code&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Using the SOAP Monitor</Title>
      <Publisher>Apache Software Foundation</Publisher>
      <Source>http://ws.apache.org/axis2/1_2/soapmonitor-module.html</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 215</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A10 Insecure Configuration Management</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.10</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3620 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The servlet &lt;Replace key="EnclosingClass.name"/&gt; fails to catch all exceptions in &lt;Replace key="EnclosingFunction.name"/&gt;. If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.&lt;AltParagraph&gt;If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;When a Servlet throws an exception, the default error response the Servlet container sends back to the user typically includes debugging information. This information is of great value to an attacker. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.

&lt;b&gt;Example 1:&lt;/b&gt; In the following method a DNS lookup failure will cause the Servlet to throw an exception.

&lt;pre&gt;
protected void doPost (HttpServletRequest req,                 
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println("hello " + addr.getHostName());
}
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; The following method will throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the parameter "name" is not part of the request.

&lt;pre&gt;
protected void doPost (HttpServletRequest req,                 
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter("name");
    ...
    out.println("hello " + name.trim());
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;All top-level Servlet methods should catch &lt;code&gt;Throwable&lt;/code&gt;, thereby minimizing the chance that the Servlet's error response mechanism is invoked. 

&lt;b&gt;Example 3:&lt;/b&gt; The method from Example 1 should be rewritten as follows:

&lt;pre&gt;
proteced void doPost (HttpServletRequest req,                 
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println("hello " + addr.getHostName());
      }catch (Throwable t) {
          logger.error("caught throwable at top level", t);
      }
  }
}
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 209, 431</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3120 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="C3693353-E32E-4B40-964A-94186E0D63B3" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can dereference a null pointer on line &lt;Replace key="LastTraceLocation.line"/&gt; because it does not check the return value of &lt;Replace key="PrimaryCall.name"/&gt;, which might return null.&lt;AltParagraph&gt;The program can dereference a null pointer because it does not check the return value of a function that might return null.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.

&lt;Paragraph&gt;
In this case, an earlier return value is used without being checked in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt;  The following code does not check to see if the string returned by &lt;code&gt;getParameter()&lt;/code&gt; is null before calling the member function &lt;code&gt;compareTo()&lt;/code&gt;, potentially causing a null dereference. 

&lt;pre&gt;
String itemName = request.getParameter(ITEM_NAME);
	if (itemName.compareTo(IMPORTANT_ITEM)) {
		...
	}
	...
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt;. The following code shows a system property that is set to null and later dereferenced by a programmer who mistakenly assumes it will always be defined. 

&lt;pre&gt;
System.clearProperty("os.name");
...
String os = System.getProperty("os.name");
if (os.equalsIgnoreCase("Windows 95") )
	System.out.println("Not supported");
&lt;/pre&gt;

The traditional defense of this coding error is: 

"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value." 

But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;If a function can return an error code or any other evidence of its success or failure, always check for the error condition, even if there is no obvious way for it to occur. In addition to preventing security errors, many initially mysterious bugs have eventually led back to a failed method call with an unchecked return value.

Create an easy to use and standard way for dealing with failure in your application. If error handling is straightforward, programmers will be less inclined to omit it. One approach to standardized error handling is to write wrappers around commonly-used functions that check and handle error conditions without additional programmer intervention. When wrappers are implemented and adopted, the use of non-wrapped equivalents can be prohibited and enforced by using custom rules. 

&lt;b&gt;Example 3:&lt;/b&gt; The following code implements a wrapper around &lt;code&gt;getParameter()&lt;/code&gt; that checks the return value of &lt;code&gt;getParameter()&lt;/code&gt; against null and uses a default value if the requested parameter is not defined.  

&lt;pre&gt;
String safeGetParameter (HttpRequest request, String name)
{
String value = request.getParameter(name);
if (value == null) {
return getDefaultValue(name)
}
return value;
}
&lt;/pre&gt;
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Watch out for programmers who want to explain away this type of issue by saying "that can never happen because ...".  Chances are good that they have developed their intuition about the way the system works by using their development workstation. If your software will eventually run under different operating systems, operating system versions, hardware configurations, or runtime environments, their intuition may not apply.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 253, 690</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP3120 CAT II, APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="F9D3C462-8D1E-4457-967F-9F082B973F88" contentType="preformatted">
  <Abstract>&lt;Content&gt;Hardcoded passwords can compromise system security in a way that cannot be easily remedied.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.
&lt;Paragraph&gt;
In this case a hardcoded password was found in the call to &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code uses a hardcoded password to connect to a database:

&lt;pre&gt;
...
DriverManager.getConnection(url, "scott", "tiger");
...
&lt;/pre&gt;

This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the &lt;code&gt;javap -c&lt;/code&gt; command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:

&lt;pre&gt;
javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.

Some third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Avoid hardcoding passwords in source code and avoid using default passwords. If a hardcoded password is the default, require that it be changed and remove it from the source code.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword and FortifyNotPassword can be used to indicate which fields and variables represent passwords.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 259</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.3.1.3, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3340 CAT I, APP3350 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="5FC849F9-EBBB-49C9-8F48-45368F98C83E" contentType="preformatted">
  <Abstract>&lt;Content&gt;Hardcoded passwords can compromise system security in a way that cannot be easily remedied.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.
&lt;Paragraph&gt;
In this case a hardcoded password was found in the call to &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code uses a hardcoded password to connect to a database:

&lt;pre&gt;
...
DriverManager.getConnection(url, "scott", "tiger");
...
&lt;/pre&gt;

This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for application, they can use the &lt;code&gt;javap -c&lt;/code&gt; command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for the example above:

&lt;pre&gt;
javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plaintext anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.

Some third party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution, the only viable option available today appears to be a proprietary one that you create.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Avoid hardcoding passwords in source code and avoid using default passwords. If a hardcoded password is the default, require that it be changed and remove it from the source code.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword and FortifyNotPassword can be used to indicate which fields and variables represent passwords.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>CWE ID 259</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.4, 6.3.1.3, 6.5.8, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3340 CAT I, APP3350 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="4FCC2666-0044-495B-AFBE-CE1160414EEB" contentType="preformatted">
  <Abstract>&lt;Content&gt;The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.
      &lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Use strong encryption algorithms with large key sizes to protect sensitive data. Examples of strong alternatives to DES are Rijndael (Advanced Encryption Standard or AES) and Triple DES (3DES). Before selecting an algorithm, first determine if your organization has standardized on a specific algorithm and implementation.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Fortify SCA will report a higher severity warning when RC4 or DES algorithms are used.</Tip>
    <Tip>Fortify SCA will report a lower severity warning when RC2 algorithm is used.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Java Cryptography Architecture Standard Algorithm Name Documentation</Title>
      <Publisher>Sun Microsystems</Publisher>
      <Source>http://java.sun.com/javase/6/docs/technotes/guides/security/StandardNames.html</Source>
    </Reference>
    <Reference>
      <Title>DES</Title>
      <Author>distributed.net</Author>
      <Source>http://www.distributed.net/des/</Source>
    </Reference>
    <Reference>
      <Title>FAQ About the Electronic Frontier Foundation's "DES Cracker" Machine</Title>
      <Publisher>Electronic Frontier Foundation</Publisher>
      <Source>http://w2.eff.org/Privacy/Crypto/Crypto_misc/DESCracker/HTML/19980716_eff_des_faq.html</Source>
    </Reference>
    <Reference>
      <Title>SDL Development Practices</Title>
      <Publisher>Microsoft</Publisher>
      <Source>http://download.microsoft.com/download/8/4/7/8471a3cb-e4bf-442a-bba4-c0c907d598c5/Michael%20Howard%20SDL%20Development%20Practices.ppsx</Source>
    </Reference>
    <Reference>
      <Title>Microsoft Security Fundamentals</Title>
      <Publisher>Microsoft</Publisher>
      <Source>http://eusecwest.com/esw06/esw06-cushman.ppt</Source>
    </Reference>
    <Reference>
      <Title>Related-key cryptanalysis of 3-WAY, Biham-DES, CAST, DES-X, NewDES, RC2, and TEA</Title>
      <Author>John Kelsey, Bruce Schneier, and David Wagner</Author>
    </Reference>
    <Reference>
      <Title>CWE ID 327</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.3, 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3150.1 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="74714BFC-EDF7-445B-8672-0996214D5845" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The function &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; sometimes fails to release a system resource allocated by &lt;Replace key="FirstTransitionFunction"/&gt; on line &lt;Replace key="FirstTraceLocation.line"/&gt;.&lt;AltParagraph&gt;The program can potentially fail to release a system resource.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The program can potentially fail to release a system resource.
&lt;Paragraph&gt;
    In this case, there are program paths on which the resource allocated in &lt;Replace key="FirstTraceLocation.file"/&gt; at line &lt;Replace key="FirstTraceLocation.line"/&gt; is not released.
&lt;/Paragraph&gt;

Resource leaks have at least two common causes:

- Error conditions and other exceptional circumstances.

- Confusion over which part of the program is responsible for releasing the resource.

Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.

&lt;b&gt;Example 1:&lt;/b&gt; The following method never closes the file handle it opens. The &lt;code&gt;finalize()&lt;/code&gt; method for &lt;code&gt;FileInputStream&lt;/code&gt; eventually calls &lt;code&gt;close()&lt;/code&gt;, but there is no guarantee as to how long it will take before the &lt;code&gt;finalize()&lt;/code&gt; method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.

&lt;pre&gt;
private void processFile(String fName) throws FileNotFoundException, IOException
{
  FileInputStream fis = new FileInputStream(fName);
  int sz;
  byte[] byteArray = new byte[BLOCK_SIZE];
  while ((sz = fis.read(byteArray)) != -1) {
    processBytes(byteArray, sz);
  }
}
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.

&lt;pre&gt;
  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;1. Never rely on &lt;code&gt;finalize()&lt;/code&gt; to reclaim resources. In order for an object's &lt;code&gt;finalize()&lt;/code&gt; method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's &lt;code&gt;finalize()&lt;/code&gt; method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to "bursty" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.

Finally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the &lt;code&gt;finalize()&lt;/code&gt; method will hang. 

2. Release resources in a &lt;code&gt;finally&lt;/code&gt; block. The code for Example 2 should be rewritten as follows:

&lt;pre&gt;
  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}
&lt;/pre&gt;

This solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. 

Also, the &lt;code&gt;execCxnSql&lt;/code&gt; method does not initialize the &lt;code&gt;stmt&lt;/code&gt; object to null. Instead, it checks to ensure that &lt;code&gt;stmt&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; before calling &lt;code&gt;safeClose()&lt;/code&gt;. Without the &lt;code&gt;null&lt;/code&gt; check, the Java compiler reports that &lt;code&gt;stmt&lt;/code&gt; might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  &lt;code&gt;stmt&lt;/code&gt; is initialized to &lt;code&gt;null&lt;/code&gt; in a more complex method, cases in which &lt;code&gt;stmt&lt;/code&gt; is used without being initialized will not be detected by the compiler. 
&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 404</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="10951BF4-F239-4F1D-8ADB-B12DE560960F" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; mishandles confidential information, which can compromise user privacy and is often illegal.&lt;AltParagraph&gt;Mishandling private information, such as customer passwords or social security numbers, can compromise user privacy and is often illegal. &lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Privacy violations occur when:

1. Private user information enters the program.
&lt;Paragraph&gt;
    In this case the data comes from &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;.
&lt;/Paragraph&gt;
2. The data is written to an external location, such as the console, file system, or network. 
&lt;Paragraph&gt;
    In this case the data is passed to &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the &lt;code&gt;getPassword()&lt;/code&gt; function returns the user-supplied plaintext password associated with the account. 

&lt;pre&gt;
pass = getPassword();
...
dbmsLog.println(id+":"+pass+":"+type+":"+tstamp);
&lt;/pre&gt;

The code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern. 

Private data can enter a program in a variety of ways:

- Directly from the user in the form of a password or personal information

- Accessed from a database or other data store by the application

- Indirectly from a partner or other third party

Sometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private. 

Security and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can in fact create risk. 

Although there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].

In response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:

- Safe Harbor Privacy Framework [3]

- Gramm-Leach Bliley Act (GLBA) [4]

- Health Insurance Portability and Accountability Act (HIPAA) [5]

- California SB-1386 [6]

Despite these regulations, privacy violations continue to occur with alarming frequency. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;When security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.

To enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.

The best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>As part of any thorough audit for privacy violations, ensure that custom rules have been written to identify all sources of private or otherwise sensitive information entering the program.  Most sources of private data cannot be identified automatically.  Without custom rules, your check for privacy violations is likely to be substantially incomplete.</Tip>
    <Tip>The Fortify Java Annotations FortifyPassword, FortifyNotPassword, FortifyPrivate and FortifyNotPrivate can be used to indicate which fields and variables represent passwords and private data.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>AOL man pleads guilty to selling 92m email addies</Title>
      <Author>J. Oates</Author>
      <Publisher>The Register</Publisher>
      <PublishedDate>2005</PublishedDate>
      <Source>http://www.theregister.co.uk/2005/02/07/aol_email_theft/</Source>
    </Reference>
    <Reference>
      <Title>Privacy Initiatives</Title>
      <Publisher>U.S. Federal Trade Commission</Publisher>
      <Source>http://www.ftc.gov/privacy/</Source>
    </Reference>
    <Reference>
      <Title>Safe Harbor Privacy Framework</Title>
      <Publisher>U.S. Department of Commerce</Publisher>
      <Source>http://www.export.gov/safeharbor/</Source>
    </Reference>
    <Reference>
      <Title>Financial Privacy: The Gramm-Leach Bliley Act (GLBA)</Title>
      <Publisher>Federal Trade Commission</Publisher>
      <Source>http://www.ftc.gov/privacy/glbact/index.html</Source>
    </Reference>
    <Reference>
      <Title>Health Insurance Portability and Accountability Act (HIPAA)</Title>
      <Publisher>U.S. Department of Human Services</Publisher>
      <Source>http://www.hhs.gov/ocr/hipaa/</Source>
    </Reference>
    <Reference>
      <Title>California SB-1386</Title>
      <Publisher>Government of the State of California</Publisher>
      <PublishedDate>2002</PublishedDate>
      <Source>http://info.sen.ca.gov/pub/01-02/bill/sen/sb_1351-1400/sb_1386_bill_20020926_chaptered.html</Source>
    </Reference>
    <Reference>
      <Title>Writing Secure Code, Second Edition</Title>
      <Author>M. Howard, D. LeBlanc</Author>
      <Publisher>Microsoft Press</Publisher>
      <PublishedDate>2003</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 359</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Information Leakage and Improper Error Handling</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.2, 3.4, 4.2, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 3.2, 3.4, 4.2, 6.5.6, 8.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3210.4 CAT II, APP3310 CAT I, APP3340 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="44346ECC-FA69-4531-BA0E-F91D030672E1" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; calls &lt;Replace key="PrimaryCall.name"/&gt; with a command built from untrusted data. This call can cause the program to execute malicious commands on behalf of an attacker.&lt;AltParagraph&gt;Executing commands from an untrusted source or in an untrusted environment can cause an application to execute malicious commands on behalf of an attacker.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Command injection vulnerabilities take two forms:

- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.

- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.

In this case we are primarily concerned with the first scenario, the possibility that an attacker may be able to control the command that is executed. Command injection vulnerabilities of this type occur when:

1. Data enters the application from an untrusted source.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;.
&lt;/Paragraph&gt;
2. The data is used as or as part of a string representing a command that is executed by the application. 
&lt;Paragraph&gt;
In this case the command is executed by &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have. 

&lt;b&gt;Example 1:&lt;/b&gt; The following code from a system utility uses the system property &lt;code&gt;APPHOME&lt;/code&gt; to determine the directory in which it is installed and then executes an initialization script based on a relative path from the specified directory. 

&lt;pre&gt;
	...
	String home = System.getProperty("APPHOME");
	String cmd = home + INITCMD; 
	java.lang.Runtime.getRuntime().exec(cmd);
	...
&lt;/pre&gt;

The code in Example 1 allows an attacker to execute arbitrary commands with the elevated privilege of the application by modifying the system property &lt;code&gt;APPHOME&lt;/code&gt; to point to a different path containing a malicious version of &lt;code&gt;INITCMD&lt;/code&gt;. Because the program does not validate the value read from the environment, if an attacker can control the value of the system property &lt;code&gt;APPHOME&lt;/code&gt;, then they can fool the application into running malicious code and take control of the system.

&lt;b&gt;Example 2:&lt;/b&gt; The following code is from an administrative web application designed allow users to kick off a backup of an Oracle database using a batch-file wrapper around the &lt;code&gt;rman&lt;/code&gt; utility and then run a &lt;code&gt;cleanup.bat&lt;/code&gt; script to delete some temporary files. The script &lt;code&gt;rmanDB.bat&lt;/code&gt; accepts a single command line parameter, which specifies what type of backup to perform. Because access to the database is restricted, the application runs the backup as a privileged user. 

&lt;pre&gt;
...
String btype = request.getParameter("backuptype");
String cmd = new String("cmd.exe /K 
\"c:\\util\\rmanDB.bat "+btype+"&amp;amp;&amp;amp;c:\\utl\\cleanup.bat\"")
System.Runtime.getRuntime().exec(cmd);
...
&lt;/pre&gt;

The problem here is that the program does not do any validation on the &lt;code&gt;backuptype&lt;/code&gt; parameter read from the user. Typically the &lt;code&gt;Runtime.exec()&lt;/code&gt; function will not execute multiple commands, but in this case the program first runs the &lt;code&gt;cmd.exe&lt;/code&gt; shell in order to run multiple commands with a single call to &lt;code&gt;Runtime.exec()&lt;/code&gt;. Once the shell is invoked, it will happily execute multiple commands separated by two ampersands. If an attacker passes a string of the form &lt;code&gt;"&amp;amp;&amp;amp; del c:\\dbms\\*.*"&lt;/code&gt;, then the application will execute this command along with the others specified by the program. Because of the nature of the application, it runs with the privileges necessary to interact with the database, which means whatever command the attacker injects will run with those privileges as well. 

&lt;b&gt;Example 3:&lt;/b&gt; The following code is from a web application that allows users access to an interface through which they can update their password on the system. Part of the process for updating passwords in certain network environments is to run a &lt;code&gt;make&lt;/code&gt; command in the &lt;code&gt;/var/yp&lt;/code&gt; directory, the code for which is shown below. 

&lt;pre&gt;
...
System.Runtime.getRuntime().exec("make");
...
&lt;/pre&gt;

The problem here is that the program does not specify an absolute path for make and fails to clean its environment prior to executing the call to &lt;code&gt;Runtime.exec()&lt;/code&gt;. If an attacker can modify the &lt;code&gt;$PATH&lt;/code&gt; variable to point to a malicious binary called &lt;code&gt;make&lt;/code&gt; and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's &lt;code&gt;make&lt;/code&gt; will now be run with these privileges, possibly giving the attacker complete control of the system.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Do not allow users to have direct control over the commands executed by the program. In cases where user input must affect the command to be run, use the input only to make a selection from a predetermined set of safe commands. If the input appears to be malicious, the value passed to the command execution function should either default to some safe selection from this set or the program should decline to execute any command at all. 

In cases where user input must be used as an argument to a command executed by the program, this approach often becomes impractical because the set of legitimate argument values is too large or too hard to keep track of. Developers often fall back on blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. Any list of unsafe characters is likely to be incomplete and will be heavily dependant on the system where the commands are executed. A better approach is to create a white list of characters that are allowed to appear in the input and accept input composed exclusively of characters in the approved set.

An attacker can indirectly control commands executed by a program by modifying the environment in which they are executed. The environment should not be trusted and precautions should be taken to prevent an attacker from using some manipulation of the environment to perform an attack. Whenever possible, commands should be controlled by the application and executed using an absolute path. In cases where the path is not known at compile time, such as for cross-platform applications, an absolute path should be constructed from trusted values during execution. Command values and paths read from configuration files or the environment should be sanity-checked against a set of invariants that define valid values. 

Other checks can sometimes be performed to detect if these sources may have been tampered with. For example, if a configuration file is world-writable, the program might refuse to run. In cases where information about the binary to be executed is known in advance, the program may perform checks to verify the identity of the binary. If a binary should always be owned by a particular user or have a particular set of access permissions assigned to it, these properties can be verified programmatically before the binary is executed.

Although it may be impossible to completely protect a program from an imaginative attacker bent on controlling the commands the program executes, be sure to apply the principle of least privilege wherever the program executes an external command: do not hold privileges that are not essential to the execution of the command.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 77, 78</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Injection Flaws</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3570 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="4ABD562C-07A6-4267-A46A-BCCC5A606C55" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt;  in &lt;Replace key="PrimaryLocation.file"/&gt; determines an object's type based its class name on line &lt;Replace key="PrimaryLocation.line"/&gt;.  This practice can lead to unexpected behavior or allow an attacker to inject a malicious class.&lt;AltParagraph&gt;Determining an object's type based on its class name can lead to unexpected behavior or allow an attacker to inject a malicious class.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Attackers may deliberately duplicate class names in order to cause a program to execute malicious code. For this reason, class names are not good type identifiers and should not be used as the basis for granting trust to a given object. 

Example 1: The following code opts to trust or distrust input from an &lt;code&gt;inputReader&lt;/code&gt; object based on its class name. If an attacker is able to supply an implementation of &lt;code&gt;inputReader&lt;/code&gt; that executes malicious commands, this code will be unable to differentiate the benign and malicious versions of the object. 

&lt;pre&gt;
if (inputReader.getClass().getName().equals("TrustedName"))
{
   input = inputReader.getInput();
   ...
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Always use a class-equivalence comparison to identify the type of an object. Do not rely on class names to convey type information. 

Example 2: The following code has been rewritten to use a class-equivalency comparison to determine whether &lt;code&gt;inputReader&lt;/code&gt; object has the expected type. 

&lt;pre&gt;
if (inputReader.getClass() == TrustedClass)
{
   input = inputReader.getInput();
   ...
}
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 486</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="FE7263A8-4A1C-4048-9F53-5B892AC7533A" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The class &lt;Replace key="EnclosingClass.name"/&gt; contains a field and a method both named &lt;Replace key="$f.name$"/&gt;, which is confusing.&lt;AltParagraph&gt;The class contains a field and a method with the same name.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;It is confusing to have a member field and a method with the same name. It makes it easy for a programmer to accidentally call the method when attempting to access the field or vice versa.

&lt;b&gt;Example 1:&lt;/b&gt; 

&lt;pre&gt;
public class Totaller {
  private int total;
  public int total() {
    ...
  }
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Rename either the method or the field. If the method returns the field, consider following the standard getter/setter naming convention.

&lt;b&gt;Example 2:&lt;/b&gt; The code in Example 1 could be rewritten in the following way:

&lt;pre&gt;
public class Totaller {
  private int total;
  public int getTotal() {
    ...
  }
}
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 398</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="811489B8-AA5B-494C-9074-926A810A1421" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;A hidden form field is used in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.&lt;AltParagraph&gt;A hidden form field is used.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Programmers often trust the contents of hidden fields, expecting that users will not be able to view them or manipulate their contents.  Attackers will violate these assumptions.  They will examine the values written to hidden fields and alter them or replace the contents with attack data.

&lt;b&gt;Example:&lt;/b&gt; An &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; tag of type &lt;code&gt;hidden&lt;/code&gt; indicates the use of a hidden field.
&lt;pre&gt;
&amp;lt;input type="hidden"&amp;gt;
&lt;/pre&gt;

If hidden fields carry sensitive information, this information will be cached the same way the rest of the page is cached.  This can lead to sensitive information being tucked away in the browser cache without the user's knowledge.
 &lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Expect that attackers will study and decode all uses of hidden fields in the application. Treat hidden fields as untrusted input. Don't store information in hidden fields if the information should not be cached along with the rest of the page.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Input Validation and Representation</Title>
      <Publisher>Fortify Software</Publisher>
      <Source>http://www.fortify.com/vulncat/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 472, 642</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>APP3610 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="F0E4F1C5-E664-40CA-A8AD-71F1DD742306" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;On line &lt;Replace key="PrimaryLocation.line"/&gt; of &lt;Replace key="PrimaryLocation.file"/&gt;, the method &lt;Replace key="EnclosingFunction.name"/&gt; invokes an XPath query built using unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary XPath queries.&lt;AltParagraph&gt;Constructing a dynamic XPath query with user input could allow an attacker to modify the statement's meaning. &lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;XPath injection occurs when:

1.       Data enters a program from an untrusted source.

&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;.
&lt;/Paragraph&gt;

2.       The data used to dynamically construct an XPath query.

&lt;Paragraph&gt;
In this case the query is passed to &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt; The following code dynamically constructs and executes an XPath query that retrieves an e-mail address for a given account ID.  The account ID is read from an HTTP request, and is therefore untrusted.

&lt;pre&gt;
...
String acctID = request.getParameter(&amp;quot;acctID&amp;quot;);
String query = null;
if(acctID != null) {
       StringBuffer sb = new StringBuffer(&amp;quot;/accounts/account[acctID='&amp;quot;);
       sb.append(acctID);
       sb.append(&amp;quot;']/email/text()&amp;quot;);
       query = sb.toString();
}

DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
domFactory.setNamespaceAware(true);
DocumentBuilder builder = domFactory.newDocumentBuilder();
Document doc = builder.parse(&amp;quot;accounts.xml&amp;quot;);
XPathFactory factory = XPathFactory.newInstance();
XPath xpath = factory.newXPath();
XPathExpression expr = xpath.compile(query);
Object result = expr.evaluate(doc, XPathConstants.NODESET);
...
&lt;/pre&gt;

Under normal conditions, such as searching for an e-mail address that belongs to the account number 1, the query that this code executes will look like the following:

&lt;code&gt;/accounts/account[acctID='1']/email/text()&lt;/code&gt;

However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if &lt;code&gt;acctID&lt;/code&gt; does not contain a single-quote character. If an attacker enters the string &lt;code&gt;1' or '1' = '1&lt;/code&gt; for &lt;code&gt;acctID&lt;/code&gt;, then the query becomes the following:

&lt;code&gt;/accounts/account[acctID='1' or '1' = '1']/email/text()&lt;/code&gt;

The addition of the &lt;code&gt;1' or '1' = '1&lt;/code&gt; condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:

&lt;code&gt;//email/text()&lt;/code&gt;

This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all e-mail addresses stored in the document, regardless of their specified owner.
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The root cause of XPath injection vulnerability is the ability of an attacker to change context in the XPath query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead.  When an XPath query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data.
 
To prevent an attacker from violating the programmer's expectations, use a whitelist to ensure that user-controlled values used in an XPath query are composed from only the expected set of characters and do not contain any XPath metacharacters given the context in which they are used. If a user-controlled value requires that it contain XPath metacharacters, use an appropriate encoding mechanism to remove their significance within the XPath query.

&lt;b&gt;Example 2&lt;/b&gt;
&lt;pre&gt;
...
String acctID = request.getParameter(&amp;quot;acctID&amp;quot;);
String query = null;
if(acctID != null) {
       Integer iAcctID = -1;
       try {
              iAcctID = Integer.parseInt(acctID);
       }
       catch (NumberFormatException e) {
              throw new InvalidParameterException();
       }
       StringBuffer sb = new StringBuffer(&amp;quot;/accounts/account[acctID='&amp;quot;);
       sb.append(iAcctID.toString());
       sb.append(&amp;quot;']/email/text()&amp;quot;);
       query = sb.toString();
}

DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();
domFactory.setNamespaceAware(true);
DocumentBuilder builder = domFactory.newDocumentBuilder();
Document doc = builder.parse(&amp;quot;accounts.xml&amp;quot;);
XPathFactory factory = XPathFactory.newInstance();
XPath xpath = factory.newXPath();
XPathExpression expr = xpath.compile(query);
Object result = expr.evaluate(doc, XPathConstants.NODESET);
...
&lt;/pre&gt;
&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 643</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Injection Flaws</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Attackers can control the filesystem path argument to &lt;Replace key="PrimaryCall.name"/&gt; at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt;, which allows them to access or modify otherwise protected files.&lt;AltParagraph&gt;Allowing user input to control paths used in filesystem operations could enable an attacker to access or modify otherwise protected system resources.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Path manipulation errors occur when the following two conditions are met:

1. An attacker can specify a path used in an operation on the filesystem. 

2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.

For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker. 
&lt;Paragraph&gt;
In this case, the attacker can specify the value that enters the program at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;, and this value is used to access a filesystem resource at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
&lt;b&gt;Example 1:&lt;/b&gt; The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as "&lt;code&gt;../../tomcat/conf/server.xml&lt;/code&gt;", which causes the application to delete one of its own configuration files. 

&lt;pre&gt;
String rName = request.getParameter("reportName");
File rFile = new File("/usr/local/apfr/reports/" + rName);
...
rFile.delete();
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension &lt;code&gt;.txt&lt;/code&gt;. 

&lt;pre&gt;
fis = new FileInputStream(cfg.getProperty("sub")+".txt");
amt = fis.read(arr);
out.println(arr);
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The best way to prevent path manipulation is with a level of indirection: create a list of legitimate resource names that a user is allowed to specify, and only allow the user to select from the list. With this approach the input provided by the user is never used directly to specify the resource name. 

In some situations this approach is impractical because the set of legitimate resource names is too large or too hard to keep track of. Programmers often resort to blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a white list of characters that are allowed to appear in the resource name and accept input composed exclusively of characters in the approved set.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>If the program is performing input validation, satisfy yourself that the validation is correct, and use Fortify Rules Builder to create a cleanse rule for the validation routine.
</Tip>
    <Tip>It is notoriously difficult to correctly implement a blacklist. If the validation logic relies on blacklisting, be skeptical. Consider different types of input encoding and different sets of meta-characters that might have special meaning when interpreted by different operating systems, databases, or other resources. Determine whether or not the blacklist can be updated easily, correctly, and completely if these requirements ever change.
</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Exploiting Software</Title>
      <Author>G. Hoglund, G. McGraw</Author>
      <Publisher>Addison-Wesley</Publisher>
      <PublishedDate>2004</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 73</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A4 Insecure Direct Object Reference</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3600 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="2254C8BD-DABE-41CB-9D12-CAC442B24079" contentType="preformatted">
  <Abstract>&lt;Content&gt;Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data. Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should no longer be relied upon to verify the authenticity of data in security-critical contexts.

Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be relied upon for security. In the case of SHA-1, current techniques still require a significant amount of computational power and are more difficult to implement. However, attackers have found the achiles heal for the algorithm, and techniques for breaking it will likely lead to the discovery of even faster attacks.
        &lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Discontinue the use of MD5 and SHA-1 for data-verification in security-critical contexts. Currently, SHA-224, SHA-256, SHA-384 and SHA-512 are good alternatives. However, these variants of the Secure Hash Algorithm are not standardized and have not been scrutinized as closely as SHA-1, so be mindful of future research that might impact the security of these algorithms.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>MD5 and MD4 Collision Generators</Title>
      <Author>Stach &amp; Liu</Author>
      <Source>http://www.stachliu.com.nyud.net:8090/research_collisions.html</Source>
    </Reference>
    <Reference>
      <Title>Finding Collisions in the Full SHA-1</Title>
      <Author>Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu</Author>
      <Source>http://people.csail.mit.edu/yiqun/SHA1AttackProceedingVersion.pdf</Source>
    </Reference>
    <Reference>
      <Title>How to Break MD5 and Other Hash Functions</Title>
      <Author>Xiaoyun Wang and Hongbo Yu</Author>
      <Source>http://www.infosec.sdu.edu.cn/uploadfile/papers/How%20to%20Break%20MD5%20and%20Other%20Hash%20Functions.pdf</Source>
    </Reference>
    <Reference>
      <Title>SDL Development Practices</Title>
      <Publisher>Microsoft</Publisher>
      <Source>http://download.microsoft.com/download/8/4/7/8471a3cb-e4bf-442a-bba4-c0c907d598c5/Michael%20Howard%20SDL%20Development%20Practices.ppsx</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 310</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Storage</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A8 Insecure Cryptographic Storage</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.3, 6.5.8</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3150.1 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="CBDB6290-DF73-42E1-8D9E-3B5C4B629761" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; co-mingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.&lt;AltParagraph&gt;Commingling trusted and untrusted data in the same data structure encourages programmers to mistakenly trust unvalidated data.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary--to move from untrusted to trusted.

A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. The most common way to make this mistake is to allow trusted and untrusted data to commingle in the same data structure. 

&lt;Paragraph&gt;
In this case the untrusted data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. The data is added to what is generally used as a trusted data structure at the call to &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example:&lt;/b&gt; The following Java code accepts an HTTP request and stores the &lt;code&gt;usrname&lt;/code&gt; parameter in the HTTP session object before checking to ensure that the user has been authenticated.

&lt;pre&gt;
usrname = request.getParameter("usrname");
if (session.getAttribute(ATTR_USR) == null) {
    session.setAttribute(ATTR_USR, usrname);
} 
&lt;/pre&gt;

Without well-established and maintained trust boundaries, programmers will inevitably lose track of which pieces of data have been validated and which have not. This confusion will eventually allow some data to be used without first being validated.
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Define clear trust boundaries in the application. Do not use the same data structure to hold trusted data in some contexts and untrusted data in other contexts. Minimize the number of ways that data can move across a trust boundary.

Trust boundary violations sometimes occur when input needs to be built up over a series of user interactions before being processed. It may not be possible to do complete input validation until all of the data has arrived. In these situations, it is still important to maintain a trust boundary. The untrusted data should be built up in a single untrusted data structure, validated, and then moved into a trusted location.
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Do not feel that you need to find a "smoking gun" situation in which data that has not been validated is assumed to be trusted. If trust boundaries are not clearly delineated and respected, validation errors are inevitable. Instead of spending time searching for an exploitable scenario, concentrate on teaching programmers to create good trust boundaries.</Tip>
    <Tip>Most programs have trust boundaries that are defined by the semantics of the application. Consider writing custom rules to check for other places where user input crosses a trust boundary.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Writing Secure Code, Second Edition</Title>
      <Author>M. Howard, D. LeBlanc</Author>
      <Publisher>Microsoft Press</Publisher>
      <PublishedDate>2003</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 501</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3520 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="4B673A45-9AD5-4CBA-945B-11A3702CDF57" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;On line &lt;Replace key="PrimaryLocation.line"/&gt; of &lt;Replace key="PrimaryLocation.file"/&gt;, the method &lt;Replace key="EnclosingFunction.name"/&gt; invokes a SQL query built using potentially unvalidated input.  This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.&lt;AltParagraph&gt;Constructing a dynamic SQL statement with user input could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. &lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;SQL injection errors occur when:

1. Data enters a program from an untrusted source.

In this case Fortify could not determine that the source of the data is trusted.

2. The data is used to dynamically construct a SQL query. 

&lt;Paragraph&gt;
In this case the data is passed to &lt;Replace key="PrimaryFunction" link="PrimaryLocation"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; at line &lt;Replace key="PrimaryLocation.line"/&gt;.
&lt;/Paragraph&gt;

&lt;b&gt;Example 1:&lt;/b&gt; The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user. 

&lt;pre&gt;
...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE owner = '" 
				+ userName + "' AND itemname = '"  
				+ itemName + "'";
	ResultSet rs = stmt.execute(query);
	...
&lt;/pre&gt;

The query that this code intends to execute follows:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = &amp;lt;userName&amp;gt;
	AND itemname = &amp;lt;itemName&amp;gt;;
&lt;/pre&gt;

However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if &lt;code&gt;itemName&lt;/code&gt; does not contain a single-quote character. If an attacker with the user name &lt;code&gt;wiley&lt;/code&gt; enters the string "&lt;code&gt;name' OR 'a'='a&lt;/code&gt;" for &lt;code&gt;itemName&lt;/code&gt;, then the query becomes the following:

&lt;pre&gt;
	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';
&lt;/pre&gt;

The addition of the &lt;code&gt;OR 'a'='a'&lt;/code&gt; condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:

&lt;pre&gt;
	SELECT * FROM items;
&lt;/pre&gt;

This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the &lt;code&gt;items&lt;/code&gt; table, regardless of their specified owner.

&lt;b&gt;Example 2:&lt;/b&gt; This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name &lt;code&gt;wiley&lt;/code&gt; enters the string "&lt;code&gt;name'; DELETE FROM items; --&lt;/code&gt;" for &lt;code&gt;itemName&lt;/code&gt;, then the query becomes the following two queries:

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'
&lt;/pre&gt;

Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.  

Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string "&lt;code&gt;name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a&lt;/code&gt;", the following three valid statements will be created: 

&lt;pre&gt;
	SELECT * FROM items 
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';
&lt;/pre&gt;

One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can: 

- Target fields that are not quoted

- Find ways to bypass the need for certain escaped meta-characters

- Use stored procedures to hide the injected meta-characters

Manually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks. 

Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks. 
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands. 

The previous example can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:

&lt;pre&gt;
...
String userName = ctx.getAuthenticatedUserName();
String itemName = request.getParameter("itemName");
String query =
        "SELECT * FROM items WHERE itemname=? AND owner=?"; 
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, itemName);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;

More complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the &lt;code&gt;WHERE&lt;/code&gt; clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values. 
&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>A common mistake is to use parameterized SQL statements that are constructed by concatenating user-controlled strings.  Of course, this defeats the purpose of using parameterized SQL statements. If you are not certain that the strings used to form statements are constants controlled by the application, do not assume that they are safe because they are not being executed directly as SQL strings. Thoroughly investigate all uses of user-controlled strings in SQL statements and verify that none can be used to modify the meaning of the query. </Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>SQL Injection Attacks by Example</Title>
      <Author>S. J. Friedl</Author>
      <Source>http://www.unixwiz.net/techtips/sql-injection.html</Source>
    </Reference>
    <Reference>
      <Title>Stop SQL Injection Attacks Before They Stop You</Title>
      <Author>P. Litwin</Author>
      <Publisher>MSDN Magazine</Publisher>
      <PublishedDate>2004</PublishedDate>
      <Source>http://msdn.microsoft.com/msdnmag/issues/04/09/SQLInjection/default.aspx</Source>
    </Reference>
    <Reference>
      <Title>SQL Injection and Oracle, Part One</Title>
      <Author>P. Finnigan</Author>
      <Publisher>Security Focus</Publisher>
      <PublishedDate>2002</PublishedDate>
      <Source>http://www.securityfocus.com/infocus/1644</Source>
    </Reference>
    <Reference>
      <Title>Writing Secure Code, Second Edition</Title>
      <Author>M. Howard, D. LeBlanc</Author>
      <Publisher>Microsoft Press</Publisher>
      <PublishedDate>2003</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 89</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A6 Injection Flaws</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.6</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3540.1 CAT, APP3540.3 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="24023E22-D6C7-4D5C-B049-38B7EFC8B408" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The call to &lt;Replace key="PrimaryCall.name"/&gt; at &lt;Replace key="PrimaryLocation.file"/&gt; line &lt;Replace key="PrimaryLocation.line"/&gt; might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.&lt;AltParagraph&gt;An attacker could cause the program to crash or otherwise become unavailable to legitimate users.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.

&lt;b&gt;Example 1:&lt;/b&gt; The following code allows a user to specify the amount of time for which a thread will sleep. By specifying a large number, an attacker can tie up the thread indefinitely. With a small number of requests, the attacker can deplete the application's thread pool.

&lt;pre&gt;
  int usrSleepTime = Integer.parseInt(usrInput);
  Thread.sleep(usrSleepTime);
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; The following code reads a String from a zip file. Because it uses the &lt;code&gt;readLine()&lt;/code&gt; method, it will read an unbounded amount of input. An attacker can take advantage of this code to cause an &lt;code&gt;OutOfMemoryException&lt;/code&gt; or to consume a large amount of memory so that the program spends more time performing garbage collection or runs out of memory during some subsequent operation.

&lt;pre&gt;
  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  String line = br.readLine();
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Validate user input to ensure that it will not cause inappropriate resource utilization.

&lt;b&gt;Example 1 Revisited:&lt;/b&gt; The following code allows a user to specify the amount of time for which a thread will sleep, but only if the value is within reasonable bounds.
&lt;pre&gt;
  int usrSleepTime = Integer.parseInt(usrInput);
  if (usrSleepTime &amp;gt;= SLEEP_MIN &amp;amp;&amp;amp;
      usrSleepTime &amp;lt;= SLEEP_MAX) {
    Thread.sleep(usrSleepTime);
  } else {
    throw new Exception("Invalid sleep duration");
  }
}
&lt;/pre&gt;

&lt;b&gt;Example 2 Revisited:&lt;/b&gt; The following code reads a String from a zip file. The maximum string length it will read is &lt;code&gt;MAX_STR_LEN&lt;/code&gt; characters.
&lt;pre&gt;
  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  StringBuffer sb = new StringBuffer();
  int intC;
  while ((intC = br.read()) != -1) {
    char c = (char) intC;
    if (c == '\n') {
      break;
    }
    if (sb.length() &amp;gt;= MAX_STR_LEN) {
      throw new Exception("input too long");
    }
    sb.append(c);
  }
  String line = sb.toString();
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 730</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="7B5AF271-BDC5-4ABE-A93A-316A14FA9028" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; includes unvalidated data in an HTTP response header on line &lt;Replace key="PrimaryLocation.line"/&gt;.  This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.&lt;AltParagraph&gt;Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Header Manipulation vulnerabilities occur when:

1. Data enters a web application through an untrusted source, most frequently an HTTP request.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;
2. The data is included in an HTTP response header sent to a web user without being validated.
&lt;Paragraph&gt;
In this case the data is sent at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
As with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.

One of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful Http Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.

&lt;b&gt;Example:&lt;/b&gt; The following code segment reads the name of the author of a weblog entry, &lt;code&gt;author&lt;/code&gt;, from an HTTP request and sets it in a cookie header of an HTTP response. 

&lt;pre&gt;
String author = request.getParameter(AUTHOR_PARAM);
...
Cookie cookie = new Cookie("author", author);
     cookie.setMaxAge(cookieExpiration);
     response.addCookie(cookie);
&lt;/pre&gt;

Assuming a string consisting of standard alpha-numeric characters, such as "Jane Smith", is submitted in the request the HTTP response including this cookie might take the following form:

&lt;pre&gt;
HTTP/1.1 200 OK
...
Set-Cookie: author=Jane Smith
...
&lt;/pre&gt;

However, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for &lt;code&gt;AUTHOR_PARAM&lt;/code&gt; does not contain any CR and LF characters. If an attacker submits a malicious string, such as "Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...", then the HTTP response would be split into two responses of the following form:

&lt;pre&gt;
HTTP/1.1 200 OK
...
Set-Cookie: author=Wiley Hacker

HTTP/1.1 200 OK
...
&lt;/pre&gt;

Clearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting and page hijacking. 

&lt;b&gt;Cross-User Defacement:&lt;/b&gt; An attacker can make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.

&lt;b&gt;Cache Poisoning:&lt;/b&gt; The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected. 

&lt;b&gt;Cross-Site Scripting:&lt;/b&gt; Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account. 

&lt;b&gt;Page Hijacking:&lt;/b&gt; In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.

&lt;b&gt;Cookie Manipulation:&lt;/b&gt; When combined with attacks like Cross-Site Request Forgery, attackers can change, add to, or even overwrite a legitimate user's cookies.

&lt;b&gt;Open Redirect:&lt;/b&gt; Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.

Many of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.

&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The solution to Header Manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.

Since Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.

The most secure approach to validation for Header Manipulation is to create a whitelist of safe characters that are allowed to appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alpha-numeric characters or an account number might only include digits 0-9.

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.

Once you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.

Many application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Many &lt;code&gt;HttpServletRequest&lt;/code&gt; implementations return a URL-encoded string from &lt;code&gt;getHeader()&lt;/code&gt;, will not cause a HTTP response splitting issue unless it is decoded first because the CR and LF characters will not carry a meta-meaning in their encoded form. However, this behavior is not specified in the J2EE standard and varies by implementation. Furthermore, even encoded user input returned from &lt;code&gt;getHeader()&lt;/code&gt; can lead to other vulnerabilities, including open redirects and other HTTP header tampering.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</Title>
      <Author>A. Klein</Author>
      <Source>http://www.packetstormsecurity.org/papers/general/whitepaper_httpresponse.pdf</Source>
    </Reference>
    <Reference>
      <Title>HTTP Response Splitting</Title>
      <Author>D. Crab</Author>
      <Source>http://www.infosecwriters.com/text_resources/pdf/HTTP_Response.pdf</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 113</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="BC8B84DA-895A-4C9D-B357-648B9F599B9C" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; writes unvalidated user input to the log on line &lt;Replace key="PrimaryLocation.line"/&gt;.  An attacker could take advantage of this behavior to forge log entries or inject malicious content into the log.&lt;AltParagraph&gt;Writing unvalidated user input to log files can allow an attacker to forge log entries or inject malicious content into the logs.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Log forging vulnerabilities occur when:

1. Data enters an application from an untrusted source. 
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;
2. The data is written to an application or system log file. 
&lt;Paragraph&gt;
In this case the data is logged by &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
Applications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.

Interpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker can render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].

&lt;b&gt;Example:&lt;/b&gt; The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened. 

&lt;pre&gt;
String val = request.getParameter("val");
try {
  int value = Integer.parseInt(val);
}
catch (NumberFormatException) {
  log.info("Failed to parse val = " + val);
}
&lt;/pre&gt;

If a user submits the string "&lt;code&gt;twenty-one&lt;/code&gt;" for &lt;code&gt;val&lt;/code&gt;, the following entry is logged:

&lt;pre&gt;
INFO: Failed to parse val=twenty-one
&lt;/pre&gt;

However, if an attacker submits the string "&lt;code&gt;twenty-one%0a%0aINFO:+User+logged+out%3dbadguy&lt;/code&gt;", the following entry is logged:

&lt;pre&gt;
INFO: Failed to parse val=twenty-one

INFO: User logged out=badguy
&lt;/pre&gt;

Clearly, attackers can use this same mechanism to insert arbitrary log entries.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Prevent log forging attacks with indirection: create a set of legitimate log entries that correspond to different events that must be logged and only log entries from this set. To capture dynamic content, such as users logging out of the system, always use server-controlled values rather than user-supplied data. This ensures that the input provided by the user is never used directly in a log entry. 

In some situations this approach is impractical because the set of legitimate log entries is too large or complicated. In these situations, developers often fall back on blacklisting. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, a list of unsafe characters can quickly become incomplete or outdated. A better approach is to create a white list of characters that are allowed to appear in log entries and accept input composed exclusively of characters in the approved set. The most critical character in most log forging attacks is the '&lt;code&gt;\n&lt;/code&gt;' (newline) character, which should never appear on a log entry white list.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Many logging operations are created only for the purpose of debugging a program during development and testing. In our experience, debugging will be enabled, either accidentally or purposefully, in production at some point. Do not excuse log forging vulnerabilities simply because a programmer says "I don't have any plans to turn that on in production".</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>The night the log was forged.</Title>
      <Author>A. Muffet</Author>
      <Source>http://doc.novsu.ac.ru/oreilly/tcpip/puis/ch10_05.htm</Source>
    </Reference>
    <Reference>
      <Title>Exploiting Software</Title>
      <Author>G. Hoglund, G. McGraw</Author>
      <Publisher>Addison-Wesley</Publisher>
      <PublishedDate>2004</PublishedDate>
    </Reference>
    <Reference>
      <Title>CWE ID 117</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1, 10.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2, 10.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="DBDBBFC6-DE26-4FC5-8347-D48032B2BF5D" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; sends unvalidated data to a web browser on line &lt;Replace key="PrimaryLocation.line"/&gt;, which can result in the browser executing malicious code.&lt;AltParagraph&gt;Sending unvalidated data to a web browser can result in the browser executing malicious code.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Cross-site scripting (XSS) vulnerabilities occur when:

1. Data enters a web application through an untrusted source, most frequently a web request or database.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;
2. The data is included in dynamic content that is sent to a web user without being validated for malicious code. 
&lt;Paragraph&gt;
In this case the data is sent at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.

&lt;b&gt;Example 1:&lt;/b&gt; The following JSP code segment reads an employee ID, &lt;code&gt;eid&lt;/code&gt;, from an HTTP request and displays it to the user. 

&lt;pre&gt;
&amp;lt;% String eid = request.getParameter("eid"); %&amp;gt; 
...
Employee ID: &amp;lt;%= eid %&amp;gt;
&lt;/pre&gt;

The code in this example operates correctly if &lt;code&gt;eid&lt;/code&gt; contains only standard alphanumeric text. If &lt;code&gt;eid&lt;/code&gt; has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.

&lt;b&gt;Example 2:&lt;/b&gt; The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.

&lt;pre&gt; 
&amp;lt;%... 
 Statement stmt = conn.createStatement();
 ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
 if (rs != null) {
  rs.next(); 
  String name = rs.getString("name");
%&amp;gt;

Employee Name: &amp;lt;%= name %&amp;gt;
&lt;/pre&gt;

As in Example 1, this code functions correctly when the values of &lt;code&gt;name&lt;/code&gt; are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of &lt;code&gt;name&lt;/code&gt; is read from a database, whose contents are apparently managed by the application. However, if the value of &lt;code&gt;name&lt;/code&gt; originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Stored XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.

- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Stored XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.

- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.

Since XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application or leaves the application destined for the user. 

The most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users. 

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:

In the content of a block-level element (in the middle of a paragraph of text):

- "&amp;lt;" is special because it introduces a tag.

- "&amp;amp;" is special because it introduces a character entity.

- "&amp;gt;" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening "&amp;lt;", but omitted it in error.

The following principles apply to attribute values:

- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.

- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.

- In attribute values without any quotes, white-space characters, such as space and tab, are special.

- "&amp;amp;" is special when used with certain attributes, because it introduces a character entity. 

In URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:

- Space, tab, and new line are special because they mark the end of the URL.

- "&amp;amp;" is special because it either introduces a character entity or separates CGI parameters.

- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.

- The "%" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, "%" must be filtered if input such as "%68%65%6C%6C%6F" becomes "hello" when it appears on the web page in question.


Within the body of a &amp;lt;SCRIPT&amp;gt; &amp;lt;/SCRIPT&amp;gt;:

- The semicolon, parenthesis, curly braces, and new line should be filtered in situations where text could be inserted directly into a pre-existing script tag. 

Server-side scripts:

- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (") on output might require additional filtering. 

Other possibilities:

- If an attacker submits a request in UTF-7, the special character '&amp;lt;' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).

Once you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.

If input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].

Many application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>In Fortify Source Code Analysis Suite, the database is treated as a source of untrusted data for XSS vulnerabilities. If the database is a trusted resource in your environment, customize Audit Workbench to filter out data flow issues generated by database sources.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Understanding Malicious Content Mitigation for Web Developers</Title>
      <Publisher>CERT</Publisher>
      <Source>http://www.cert.org/tech_tips/malicious_code_mitigation.html#9</Source>
    </Reference>
    <Reference>
      <Title>HTML 4.01 Specification</Title>
      <Publisher>W3</Publisher>
      <Source>http://www.w3.org/TR/html4/sgml/entities.html#h-24.2</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 79, 80</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A4 Cross Site Scripting</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A1 Cross Site Scripting (XSS)</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I, APP3580 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="B30AA17C-87EC-42CF-9160-CFDF122CE28E" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; never uses the value it assigns to the variable &lt;Replace key="$var.name$"/&gt; on line &lt;Replace key="PrimaryLocation.line"/&gt;.&lt;AltParagraph&gt;The variable's value is assigned but never used, making it a dead store.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;This variable's value is not used. After the assignment, the variable is either assigned another value or goes out of scope.

&lt;b&gt;Example:&lt;/b&gt; The following code excerpt assigns to the variable &lt;code&gt;r&lt;/code&gt; and then overwrites the value without using it.

&lt;pre&gt;
  r = getName();
  r = getNewBuffer(buf);
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Remove unnecessary assignments in order to make the code easier to understand and maintain.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 563</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>APP3050 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="B7DFF4A8-9817-4418-A35B-E70D10DC825E" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The function &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; sometimes fails to release a system resource allocated by &lt;Replace key="FirstTransitionFunction"/&gt; on line &lt;Replace key="FirstTraceLocation.line"/&gt;.&lt;AltParagraph&gt;The program can potentially fail to release a system resource.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;The program can potentially fail to release a system resource.
&lt;Paragraph&gt;
    In this case, there are program paths on which the resource allocated in &lt;Replace key="FirstTraceLocation.file"/&gt; at line &lt;Replace key="FirstTraceLocation.line"/&gt; is not released.
&lt;/Paragraph&gt;

Resource leaks have at least two common causes:

- Error conditions and other exceptional circumstances.

- Confusion over which part of the program is responsible for releasing the resource.

Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker might be able to launch a denial of service attack by depleting the resource pool.

&lt;b&gt;Example 1:&lt;/b&gt; The following method never closes the file handle it opens. The &lt;code&gt;finalize()&lt;/code&gt; method for &lt;code&gt;FileInputStream&lt;/code&gt; eventually calls &lt;code&gt;close()&lt;/code&gt;, but there is no guarantee as to how long it will take before the &lt;code&gt;finalize()&lt;/code&gt; method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.

&lt;pre&gt;
private void processFile(String fName) throws FileNotFoundException, IOException
{
  FileInputStream fis = new FileInputStream(fName);
  int sz;
  byte[] byteArray = new byte[BLOCK_SIZE];
  while ((sz = fis.read(byteArray)) != -1) {
    processBytes(byteArray, sz);
  }
}
&lt;/pre&gt;

&lt;b&gt;Example 2:&lt;/b&gt; Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.

&lt;pre&gt;
  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();
&lt;/pre&gt;
&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;1. Never rely on &lt;code&gt;finalize()&lt;/code&gt; to reclaim resources. In order for an object's &lt;code&gt;finalize()&lt;/code&gt; method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's &lt;code&gt;finalize()&lt;/code&gt; method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to "bursty" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.

Finally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the &lt;code&gt;finalize()&lt;/code&gt; method will hang. 

2. Release resources in a &lt;code&gt;finally&lt;/code&gt; block. The code for Example 2 should be rewritten as follows:

&lt;pre&gt;
  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}
&lt;/pre&gt;

This solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed. 

Also, the &lt;code&gt;execCxnSql&lt;/code&gt; method does not initialize the &lt;code&gt;stmt&lt;/code&gt; object to null. Instead, it checks to ensure that &lt;code&gt;stmt&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; before calling &lt;code&gt;safeClose()&lt;/code&gt;. Without the &lt;code&gt;null&lt;/code&gt; check, the Java compiler reports that &lt;code&gt;stmt&lt;/code&gt; might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  &lt;code&gt;stmt&lt;/code&gt; is initialized to &lt;code&gt;null&lt;/code&gt; in a more complex method, cases in which &lt;code&gt;stmt&lt;/code&gt; is used without being initialized will not be detected by the compiler. 
&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 404</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A9 Application Denial of Service</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>APP6080 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="A984452A-DD31-47C9-83A6-76F5EA13133F" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; never uses the initial value it assigns to the variable &lt;Replace key="$var.name$"/&gt; on line &lt;Replace key="PrimaryLocation.line"/&gt;.&lt;AltParagraph&gt;The variable's value is assigned but never used, making it a dead store.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;This variable's initial value is not used. After initialization, the variable is either assigned another value or goes out of scope.

&lt;b&gt;Example:&lt;/b&gt; The following code excerpt assigns to the variable &lt;code&gt;r&lt;/code&gt; and then overwrites the value without using it.

&lt;pre&gt;
  int r = getNum();
  r = getNewNum(buf);
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Remove unnecessary assignments in order to make the code easier to understand and maintain.&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>CWE ID 398</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>APP3050 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="35DEAC53-264A-472F-A1FD-F17DD14841A7" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The class &lt;Replace key="EnclosingClass.name"/&gt; overrides only one of &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt;.&lt;AltParagraph&gt;This class overrides only one of &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt;.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Java objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes. In other words, if &lt;code&gt;a.equals(b) == true&lt;/code&gt; then &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;. 

Failure to uphold this invariant is likely to cause trouble if objects of this class are stored in a collection. If the objects of the class in question are used as a key in a Hashtable or if they are inserted into a Map or Set, it is critical that equal objects have equal hashcodes.

&lt;b&gt;Example 1:&lt;/b&gt; The following class overrides &lt;code&gt;equals()&lt;/code&gt; but not &lt;code&gt;hashCode()&lt;/code&gt;.

&lt;pre&gt;
public class halfway() {
  public boolean equals(Object obj) {
    ...
  }
}
&lt;/pre&gt;&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The FindBugs documentation recommends the following simple "starter" implementation of &lt;code&gt;hashCode()&lt;/code&gt; [1]. It is highly inefficient, but it will produce correct results. If you do not believe that &lt;code&gt;hashCode()&lt;/code&gt; is important for your program, consider using this implementation.

&lt;b&gt;Example 2:&lt;/b&gt; The code in Example 1 could be rewritten in the following way:

&lt;pre&gt;
public class halfway() {
  public boolean equals(Object obj) {
    ...
  }

public int hashCode() {
    assert false : "hashCode not designed";
    return 42; // any arbitrary constant will do 
  }
} 
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>FindBugs User Manual</Title>
      <Author>D. H. Hovermeyer</Author>
      <Source>http://findbugs.sourceforge.net/manual/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 581</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
  </References>
</Description>
<Description classID="AA4DA365-6889-4FC1-B666-1864FC00D921" contentType="preformatted">
  <Abstract>&lt;Content&gt;A security constraint that does not specify a user data constraint cannot guarantee that restricted resources will be protected at the transport layer.&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;
&lt;code&gt;web.xml&lt;/code&gt; security constraints are typically used for role based access control, but the optional &lt;code&gt;user-data-constraint&lt;/code&gt; element specifies a transport guarantee that prevents content from being transmitted insecurely.

Within the &lt;code&gt;&amp;lt;user-data-constraint&amp;gt;&lt;/code&gt; tag, the &lt;code&gt;&amp;lt;transport-guarantee&amp;gt;&lt;/code&gt; tag defines how communication should be handled. There are three levels of transport guarantee:

1) &lt;code&gt;NONE&lt;/code&gt; means that the application does not require any transport guarantees.
2) &lt;code&gt;INTEGRAL&lt;/code&gt; means that the application requires that data sent between the client and server be sent in such a way that it can’t be changed in transit.
3) &lt;code&gt;CONFIDENTIAL&lt;/code&gt; means that the application requires that data be transmitted in a fashion that prevents other entities from observing the contents of the transmission.

&lt;Paragraph&gt;In this case, the security constraint defined at line &lt;Replace key="PrimaryLocation.line"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; does not specify a transport guarantee.&lt;/Paragraph&gt;

In most circumstances, the use of &lt;code&gt;INTEGRAL&lt;/code&gt; or &lt;code&gt;CONFIDENTIAL&lt;/code&gt; means that SSL/TLS is required. If the &lt;code&gt;&amp;lt;user-data-constraint&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transport-guarantee&amp;gt;&lt;/code&gt; tags are omitted, the transport guarantee defaults to &lt;code&gt;NONE&lt;/code&gt;.

&lt;b&gt;Example 1:&lt;/b&gt; The following security constraint does not specify a transport guarantee.
&lt;pre&gt;
&amp;lt;security-constraint&amp;gt;
    &amp;lt;web-resource-collection&amp;gt;
        &amp;lt;web-resource-name&amp;gt;Storefront&amp;lt;/web-resource-name&amp;gt;
        &amp;lt;description&amp;gt;Allow Customers and Employees access to online store front&amp;lt;/description&amp;gt;
        &amp;lt;url-pattern&amp;gt;/store/shop/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/web-resource-collection&amp;gt;
    &amp;lt;auth-constraint&amp;gt;
        &amp;lt;description&amp;gt;Anyone&amp;lt;/description&amp;gt;
        &amp;lt;role-name&amp;gt;anyone&amp;lt;/role-name&amp;gt;
    &amp;lt;/auth-constraint&amp;gt;
&amp;lt;/security-constraint&amp;gt;
&lt;/pre&gt;
            
This category is from the Cigital Java Rulepack. http://www.cigital.com/securitypack/&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Specify a &lt;code&gt;CONFIDENTIAL&lt;/code&gt; transport guarantee whenever you define a authorization constraint. Once you decide to encrypt traffic to any part of your application, do not make the mistake of allowing unencrypted traffic to other parts of the application, which could allow session cookies or other sensitive information to be transmitted over insecure channels. 

&lt;b&gt;Example 2:&lt;/b&gt; The following security constraint specifies a &lt;code&gt;CONFIDENTIAL&lt;/code&gt; transport guarantee.
&lt;pre&gt;
&amp;lt;security-constraint&amp;gt;
    &amp;lt;web-resource-collection&amp;gt;
        &amp;lt;web-resource-name&amp;gt;Storefront&amp;lt;/web-resource-name&amp;gt;
        &amp;lt;description&amp;gt;Allow Customers and Employees access to online store front&amp;lt;/description&amp;gt;
        &amp;lt;url-pattern&amp;gt;/store/shop/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/web-resource-collection&amp;gt;
    &amp;lt;auth-constraint&amp;gt;
        &amp;lt;description&amp;gt;Anyone&amp;lt;/description&amp;gt;
        &amp;lt;role-name&amp;gt;anyone&amp;lt;/role-name&amp;gt;
    &amp;lt;/auth-constraint&amp;gt;
    &amp;lt;user-data-constraint&amp;gt;
        &amp;lt;transport-guarantee&amp;gt;CONFIDENTIAL&amp;lt;/transport-guarantee&amp;gt;
    &amp;lt;/user-data-constraint&amp;gt;
&amp;lt;/security-constraint&amp;gt;
&lt;/pre&gt;
            &lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>Java EE 5 Tutorial: Establishing a Secure Connection Using SSL</Title>
      <Author>Sun Microsystems, Inc.</Author>
      <Source>http://java.sun.com/javaee/5/docs/tutorial/doc/bnbxw.html</Source>
    </Reference>
    <Reference>
      <Title>Java Servlet Specification Version 2.3</Title>
      <Author>Sun Microsystems, Inc.</Author>
      <Source>http://www.jcp.org/aboutJava/communityprocess/final/jsr053/</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 5</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A10 Insecure Configuration Management</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A9 Insecure Communications</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 4.1, 6.5.10</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 4.1, 6.3.1.4, 6.5.9</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="264C499A-C0F5-479E-9758-9E8C24468D70" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;Without proper access control, the method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; can execute a SQL statement on line &lt;Replace key="PrimaryLocation.line"/&gt; that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.&lt;AltParagraph&gt;Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Database access control errors occur when:

1.	Data enters a program from an untrusted source.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;

2.	The data is used to specify the value of a primary key in a SQL query. 
&lt;Paragraph&gt;
In this case the data is used by &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
&lt;b&gt;Example 1:&lt;/b&gt; The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user.  

&lt;pre&gt;
...
id = Integer.decode(request.getParameter("invoiceID"));
String query = "SELECT * FROM invoices WHERE id = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, id);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;

The problem is that the developer has failed to consider all of the possible values of &lt;code&gt;id&lt;/code&gt;. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;Rather than relying on the presentation layer to restrict values submitted by the user, access control should be handled by the application and database layers. Under no circumstances should a user be allowed to retrieve or modify a row in the database without the appropriate permissions. Every query that accesses the database should enforce this policy, which can often be accomplished by simply including the current authenticated username as part of the query. 

&lt;b&gt;Example 2:&lt;/b&gt; The following code implements the same functionality as Example 1 but imposes an additional constraint requiring that the current authenticated user have specific access to the invoice. 

&lt;pre&gt;
...
userName = ctx.getAuthenticatedUserName();
id = Integer.decode(request.getParameter("invoiceID"));
String query = 
        "SELECT * FROM invoices WHERE id = ? AND user = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, id);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...
&lt;/pre&gt;&lt;/Content&gt;</Recommendations>
  <References>
    <Reference>
      <Title>SQL Injection Attacks by Example</Title>
      <Author>S. J. Friedl</Author>
      <Source>http://www.unixwiz.net/techtips/sql-injection.html</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 566</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A2 Broken Access Control</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A4 Insecure Direct Object Reference</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.4</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
<Description classID="790A125E-5BFE-4931-A51A-29B7D5BECC93" contentType="preformatted">
  <Abstract>&lt;Content&gt;&lt;Paragraph&gt;The method &lt;Replace key="EnclosingFunction.name"/&gt; in &lt;Replace key="PrimaryLocation.file"/&gt; includes unvalidated data in an HTTP response header on line &lt;Replace key="PrimaryLocation.line"/&gt;.  This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.&lt;AltParagraph&gt;Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.&lt;/AltParagraph&gt;&lt;/Paragraph&gt;&lt;/Content&gt;</Abstract>
  <Explanation>&lt;Content&gt;Header Manipulation vulnerabilities occur when:

1. Data enters a web application through an untrusted source, most frequently an HTTP request.
&lt;Paragraph&gt;
In this case the data enters at &lt;Replace key="SourceFunction" link="SourceLocation"/&gt; in &lt;Replace key="SourceLocation.file"/&gt; at line &lt;Replace key="SourceLocation.line"/&gt;. 
&lt;/Paragraph&gt;
2. The data is included in an HTTP response header sent to a web user without being validated.
&lt;Paragraph&gt;
In this case the data is sent at &lt;Replace key="SinkFunction" link="SinkLocation"/&gt; in &lt;Replace key="SinkLocation.file"/&gt; at line &lt;Replace key="SinkLocation.line"/&gt;.
&lt;/Paragraph&gt;
As with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.

One of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful Http Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.

&lt;b&gt;Example:&lt;/b&gt; The following code segment reads the name of the author of a weblog entry, &lt;code&gt;author&lt;/code&gt;, from an HTTP request and sets it in a cookie header of an HTTP response. 

&lt;pre&gt;
String author = request.getParameter(AUTHOR_PARAM);
...
Cookie cookie = new Cookie("author", author);
     cookie.setMaxAge(cookieExpiration);
     response.addCookie(cookie);
&lt;/pre&gt;

Assuming a string consisting of standard alpha-numeric characters, such as "Jane Smith", is submitted in the request the HTTP response including this cookie might take the following form:

&lt;pre&gt;
HTTP/1.1 200 OK
...
Set-Cookie: author=Jane Smith
...
&lt;/pre&gt;

However, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for &lt;code&gt;AUTHOR_PARAM&lt;/code&gt; does not contain any CR and LF characters. If an attacker submits a malicious string, such as "Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...", then the HTTP response would be split into two responses of the following form:

&lt;pre&gt;
HTTP/1.1 200 OK
...
Set-Cookie: author=Wiley Hacker

HTTP/1.1 200 OK
...
&lt;/pre&gt;

Clearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting and page hijacking. 

&lt;b&gt;Cross-User Defacement:&lt;/b&gt; An attacker can make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.

&lt;b&gt;Cache Poisoning:&lt;/b&gt; The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected. 

&lt;b&gt;Cross-Site Scripting:&lt;/b&gt; Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account. 

&lt;b&gt;Page Hijacking:&lt;/b&gt; In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.

&lt;b&gt;Cookie Manipulation:&lt;/b&gt; When combined with attacks like Cross-Site Request Forgery, attackers can change, add to, or even overwrite a legitimate user's cookies.

&lt;b&gt;Open Redirect:&lt;/b&gt; Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.

Many of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.

&lt;/Content&gt;</Explanation>
  <Recommendations>&lt;Content&gt;The solution to Header Manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.

Since Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.

The most secure approach to validation for Header Manipulation is to create a whitelist of safe characters that are allowed to appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alpha-numeric characters or an account number might only include digits 0-9.

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.

Once you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.

Many application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.&lt;/Content&gt;</Recommendations>
  <Tips>
    <Tip>Many &lt;code&gt;HttpServletRequest&lt;/code&gt; implementations return a URL-encoded string from &lt;code&gt;getHeader()&lt;/code&gt;, will not cause a HTTP response splitting issue unless it is decoded first because the CR and LF characters will not carry a meta-meaning in their encoded form. However, this behavior is not specified in the J2EE standard and varies by implementation. Furthermore, even encoded user input returned from &lt;code&gt;getHeader()&lt;/code&gt; can lead to other vulnerabilities, including open redirects and other HTTP header tampering.</Tip>
    <Tip>Fortify RTA adds protection against this category.</Tip>
  </Tips>
  <References>
    <Reference>
      <Title>Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</Title>
      <Author>A. Klein</Author>
      <Source>http://www.packetstormsecurity.org/papers/general/whitepaper_httpresponse.pdf</Source>
    </Reference>
    <Reference>
      <Title>HTTP Response Splitting</Title>
      <Author>D. Crab</Author>
      <Source>http://www.infosecwriters.com/text_resources/pdf/HTTP_Response.pdf</Source>
    </Reference>
    <Reference>
      <Title>CWE ID 113</Title>
      <Author>Common Weakness Enumeration</Author>
    </Reference>
    <Reference>
      <Title>A1 Unvalidated Input</Title>
      <Author>OWASP Top 10 2004</Author>
    </Reference>
    <Reference>
      <Title>A2 Injection Flaws</Title>
      <Author>OWASP Top 10 2007</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.5.1</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.1</Author>
    </Reference>
    <Reference>
      <Title>Requirement 6.3.1.1, 6.5.2</Title>
      <Author>Payment Card Industry Data Security Standard Version 1.2</Author>
    </Reference>
    <Reference>
      <Title>APP3510 CAT I</Title>
      <Author>Security Technical Implementation Guide Version 2</Author>
    </Reference>
  </References>
</Description>
</FVDL>